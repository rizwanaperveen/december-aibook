---
sidebar_position: 3
---

# Chapter 4.3 â€“ LLM-Based Cognitive Planning

## Learning Objectives
- Implement cognitive planning with Large Language Models
- Integrate ROS 2 action orchestration with LLMs
- Design error recovery mechanisms for autonomous systems
- Create tool-using agents for humanoid robotics

## Cognitive Planning with LLMs

Large Language Models can serve as high-level cognitive planners for humanoid robots, decomposing complex tasks into executable sequences:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from action_msgs.msg import GoalStatus
from rclpy.action import ActionClient
from geometry_msgs.msg import Pose, Point
from move_base_msgs.action import MoveBase
from manipulation_msgs.action import GraspObject
from sensor_msgs.msg import Image
import openai
import json
import re
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import asyncio
import threading
import queue

@dataclass
class TaskPlan:
    """Represents a high-level task plan"""
    id: str
    description: str
    subtasks: List['SubTask']
    dependencies: List[str]  # IDs of tasks that must complete first
    priority: int = 1  # Higher number = higher priority

@dataclass
class SubTask:
    """Represents a subtask in the plan"""
    id: str
    action_type: str  # 'navigation', 'manipulation', 'perception', 'communication'
    parameters: Dict[str, Any]
    estimated_duration: float  # in seconds
    success_criteria: List[str]  # Conditions that define success
    recovery_procedures: List[str]  # What to do if it fails

class CognitivePlannerNode(Node):
    def __init__(self):
        super().__init__('cognitive_planner_node')

        # Initialize LLM client
        self.llm_client = openai.OpenAI(api_key=self.get_parameter_or_set_default('openai_api_key', ''))

        # ROS 2 action clients
        self.nav_client = ActionClient(self, MoveBase, 'move_base')
        self.grasp_client = ActionClient(self, GraspObject, 'grasp_object')

        # Subscriptions
        self.high_level_command_sub = self.create_subscription(
            String, '/high_level_command', self.command_callback, 10
        )
        self.task_status_sub = self.create_subscription(
            String, '/task_status', self.task_status_callback, 10
        )

        # Publishers
        self.plan_pub = self.create_publisher(String, '/generated_plan', 10)
        self.status_pub = self.create_publisher(String, '/cognitive_status', 10)

        # Task management
        self.current_plan: Optional[TaskPlan] = None
        self.active_tasks: Dict[str, Any] = {}
        self.completed_tasks: List[str] = []
        self.failed_tasks: List[str] = []

        # System state
        self.robot_state = {
            'location': Point(x=0.0, y=0.0, z=0.0),
            'battery_level': 1.0,
            'grippers': {'left': 'free', 'right': 'free'},
            'current_task': None
        }

        # Environment knowledge
        self.known_objects = {}
        self.known_locations = {}

        # Initialize
        self.load_environment_knowledge()
        self.plan_queue = queue.Queue()

        self.get_logger().info('Cognitive Planner Node initialized')

    def get_parameter_or_set_default(self, param_name: str, default_value: str) -> str:
        """Get parameter or set default"""
        param_desc = rclpy.parameter.ParameterDescriptor()
        self.declare_parameter(param_name, default_value, param_desc)
        return self.get_parameter(param_name).value or default_value

    def command_callback(self, msg: String):
        """Handle high-level natural language commands"""
        command = msg.data
        self.get_logger().info(f'Received high-level command: "{command}"')

        # Generate plan using LLM
        plan = self.generate_plan_with_llm(command)

        if plan:
            self.current_plan = plan
            self.execute_plan(plan)
        else:
            self.get_logger().error(f'Failed to generate plan for command: "{command}"')

    def generate_plan_with_llm(self, command: str) -> Optional[TaskPlan]:
        """Generate a task plan using LLM"""
        try:
            # Construct prompt for the LLM
            prompt = self.construct_planning_prompt(command)

            response = self.llm_client.chat.completions.create(
                model="gpt-4-turbo",  # Use appropriate model
                messages=[
                    {
                        "role": "system",
                        "content": self.get_planning_system_prompt()
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.3,
                max_tokens=1000,
                response_format={"type": "json_object"}
            )

            # Parse the response
            plan_json = json.loads(response.choices[0].message.content)

            # Convert to TaskPlan object
            plan = self.json_to_task_plan(plan_json)

            # Publish the plan
            plan_msg = String()
            plan_msg.data = json.dumps(plan_json)
            self.plan_pub.publish(plan_msg)

            self.get_logger().info(f'Generated plan with {len(plan.subtasks)} subtasks')

            return plan

        except Exception as e:
            self.get_logger().error(f'Error generating plan with LLM: {e}')
            return None

    def construct_planning_prompt(self, command: str) -> str:
        """Construct prompt for LLM planning"""
        prompt = f"""
        You are a cognitive planner for a humanoid robot. Your task is to decompose high-level commands into executable subtasks.

        Command: "{command}"

        Current Robot State:
        - Location: {self.robot_state['location']}
        - Battery Level: {self.robot_state['battery_level']:.2f}
        - Grippers: {self.robot_state['grippers']}
        - Available Actions: navigation, manipulation, perception, communication

        Known Objects: {list(self.known_objects.keys())}
        Known Locations: {list(self.known_locations.keys())}

        Please generate a detailed task plan in JSON format with the following structure:
        {{
            "id": "unique_plan_id",
            "description": "Brief description of the plan",
            "subtasks": [
                {{
                    "id": "unique_subtask_id",
                    "action_type": "navigation|manipulation|perception|communication",
                    "parameters": {{"param1": "value1", "param2": "value2"}},
                    "estimated_duration": 10.0,
                    "success_criteria": ["condition1", "condition2"],
                    "recovery_procedures": ["procedure1", "procedure2"]
                }}
            ],
            "dependencies": ["subtask_id_1", "subtask_id_2"]
        }}

        The plan should be executable by a humanoid robot with basic navigation and manipulation capabilities.
        Consider safety, efficiency, and the robot's current state when generating the plan.
        """

        return prompt

    def get_planning_system_prompt(self) -> str:
        """Get system prompt for planning"""
        return """
        You are an expert cognitive planner for humanoid robots. Your role is to decompose complex natural language commands into executable task plans.

        Guidelines:
        1. Break down complex tasks into atomic subtasks
        2. Ensure each subtask is achievable with basic robot capabilities
        3. Consider spatial relationships and object affordances
        4. Include error recovery procedures
        5. Respect robot limitations (reach, carrying capacity, etc.)
        6. Prioritize safety in all actions
        7. Consider dependencies between subtasks

        Action Types:
        - navigation: Moving the robot to a location
        - manipulation: Grasping, placing, opening, closing objects
        - perception: Looking for objects, scanning environment
        - communication: Speaking, signaling, acknowledging

        Each subtask should have:
        - Specific parameters for execution
        - Success criteria that can be verified
        - Recovery procedures for common failure modes
        - Estimated duration for planning purposes
        """

    def json_to_task_plan(self, plan_json: Dict[str, Any]) -> TaskPlan:
        """Convert JSON response to TaskPlan object"""
        subtasks = []
        for subtask_json in plan_json.get('subtasks', []):
            subtask = SubTask(
                id=subtask_json.get('id', f'subtask_{len(subtasks)}'),
                action_type=subtask_json.get('action_type', 'unknown'),
                parameters=subtask_json.get('parameters', {}),
                estimated_duration=subtask_json.get('estimated_duration', 10.0),
                success_criteria=subtask_json.get('success_criteria', []),
                recovery_procedures=subtask_json.get('recovery_procedures', [])
            )
            subtasks.append(subtask)

        plan = TaskPlan(
            id=plan_json.get('id', 'plan_0'),
            description=plan_json.get('description', 'No description'),
            subtasks=subtasks,
            dependencies=plan_json.get('dependencies', []),
            priority=plan_json.get('priority', 1)
        )

        return plan

    def execute_plan(self, plan: TaskPlan):
        """Execute the generated plan"""
        self.get_logger().info(f'Executing plan: {plan.description}')

        for subtask in plan.subtasks:
            if subtask.id in self.completed_tasks:
                continue  # Already completed

            if self.check_dependencies_met(subtask, plan.dependencies):
                self.execute_subtask(subtask)
            else:
                self.get_logger().warn(f'Skipping subtask {subtask.id} - dependencies not met')

    def check_dependencies_met(self, subtask: SubTask, dependencies: List[str]) -> bool:
        """Check if dependencies for a subtask are met"""
        # For now, just check if dependent tasks are completed
        # In practice, this would be more sophisticated
        for dep in dependencies:
            if dep not in self.completed_tasks:
                return False
        return True

    def execute_subtask(self, subtask: SubTask):
        """Execute a single subtask"""
        self.get_logger().info(f'Executing subtask: {subtask.id} ({subtask.action_type})')

        if subtask.action_type == 'navigation':
            self.execute_navigation_subtask(subtask)
        elif subtask.action_type == 'manipulation':
            self.execute_manipulation_subtask(subtask)
        elif subtask.action_type == 'perception':
            self.execute_perception_subtask(subtask)
        elif subtask.action_type == 'communication':
            self.execute_communication_subtask(subtask)
        else:
            self.get_logger().error(f'Unknown action type: {subtask.action_type}')

    def execute_navigation_subtask(self, subtask: SubTask):
        """Execute navigation subtask"""
        try:
            target_pose = Pose()
            target_pose.position.x = subtask.parameters.get('x', 0.0)
            target_pose.position.y = subtask.parameters.get('y', 0.0)
            target_pose.position.z = subtask.parameters.get('z', 0.0)

            # Create navigation goal
            goal_msg = MoveBase.Goal()
            goal_msg.target_pose.header.frame_id = 'map'
            goal_msg.target_pose.header.stamp = self.get_clock().now().to_msg()
            goal_msg.target_pose.pose = target_pose

            # Send goal asynchronously
            self.nav_client.wait_for_server()
            future = self.nav_client.send_goal_async(goal_msg)

            # Store active task
            self.active_tasks[subtask.id] = {
                'type': 'navigation',
                'future': future,
                'subtask': subtask
            }

            # Wait for result in a separate thread
            threading.Thread(
                target=self.wait_for_navigation_result,
                args=(subtask.id, future),
                daemon=True
            ).start()

        except Exception as e:
            self.get_logger().error(f'Error executing navigation subtask: {e}')
            self.handle_subtask_failure(subtask)

    def execute_manipulation_subtask(self, subtask: SubTask):
        """Execute manipulation subtask"""
        try:
            # Create manipulation goal
            goal_msg = GraspObject.Goal()
            goal_msg.object_name = subtask.parameters.get('object_name', '')
            goal_msg.pre_grasp_distance = subtask.parameters.get('approach_distance', 0.1)
            goal_msg.grasp_type = subtask.parameters.get('grasp_type', 'pinch')

            # Send goal
            self.grasp_client.wait_for_server()
            future = self.grasp_client.send_goal_async(goal_msg)

            # Store active task
            self.active_tasks[subtask.id] = {
                'type': 'manipulation',
                'future': future,
                'subtask': subtask
            }

            # Wait for result
            threading.Thread(
                target=self.wait_for_manipulation_result,
                args=(subtask.id, future),
                daemon=True
            ).start()

        except Exception as e:
            self.get_logger().error(f'Error executing manipulation subtask: {e}')
            self.handle_subtask_failure(subtask)

    def execute_perception_subtask(self, subtask: SubTask):
        """Execute perception subtask"""
        try:
            # For perception, we might need to call a service or trigger object detection
            object_name = subtask.parameters.get('object_name', 'any')
            search_area = subtask.parameters.get('search_area', 'current_view')

            # This would typically call object detection service
            # For now, simulate the process
            result = self.simulate_perception_task(object_name, search_area)

            if result:
                self.handle_subtask_success(subtask)
            else:
                self.handle_subtask_failure(subtask)

        except Exception as e:
            self.get_logger().error(f'Error executing perception subtask: {e}')
            self.handle_subtask_failure(subtask)

    def execute_communication_subtask(self, subtask: SubTask):
        """Execute communication subtask"""
        try:
            # Publish speech command
            speech_pub = self.create_publisher(String, '/tts_input', 10)
            speech_msg = String()
            speech_msg.data = subtask.parameters.get('text', 'Hello')
            speech_pub.publish(speech_msg)

            # Mark as completed immediately
            self.handle_subtask_success(subtask)

        except Exception as e:
            self.get_logger().error(f'Error executing communication subtask: {e}')
            self.handle_subtask_failure(subtask)

    def wait_for_navigation_result(self, task_id: str, future):
        """Wait for navigation result"""
        try:
            goal_handle = future.result()
            result_future = goal_handle.get_result_async()

            # Wait for result with timeout
            rclpy.spin_until_future_complete(self, result_future, timeout_sec=30.0)

            if result_future.result() is not None:
                result = result_future.result().result
                status = result_future.result().status

                if status == GoalStatus.STATUS_SUCCEEDED:
                    self.handle_subtask_success(self.active_tasks[task_id]['subtask'])
                else:
                    self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])
            else:
                self.get_logger().error(f'Navigation task {task_id} timed out')
                self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])

        except Exception as e:
            self.get_logger().error(f'Error waiting for navigation result: {e}')
            self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])

        finally:
            if task_id in self.active_tasks:
                del self.active_tasks[task_id]

    def wait_for_manipulation_result(self, task_id: str, future):
        """Wait for manipulation result"""
        try:
            goal_handle = future.result()
            result_future = goal_handle.get_result_async()

            # Wait for result with timeout
            rclpy.spin_until_future_complete(self, result_future, timeout_sec=30.0)

            if result_future.result() is not None:
                result = result_future.result().result
                status = result_future.result().status

                if status == GoalStatus.STATUS_SUCCEEDED:
                    self.handle_subtask_success(self.active_tasks[task_id]['subtask'])
                else:
                    self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])
            else:
                self.get_logger().error(f'Manipulation task {task_id} timed out')
                self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])

        except Exception as e:
            self.get_logger().error(f'Error waiting for manipulation result: {e}')
            self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])

        finally:
            if task_id in self.active_tasks:
                del self.active_tasks[task_id]

    def handle_subtask_success(self, subtask: SubTask):
        """Handle successful subtask completion"""
        self.get_logger().info(f'Subtask {subtask.id} completed successfully')
        self.completed_tasks.append(subtask.id)

        # Update robot state based on task completion
        self.update_robot_state_after_task(subtask)

        # Check if overall plan is complete
        if self.current_plan and all(st.id in self.completed_tasks for st in self.current_plan.subtasks):
            self.get_logger().info('Plan completed successfully!')
            self.current_plan = None

    def handle_subtask_failure(self, subtask: SubTask):
        """Handle subtask failure and recovery"""
        self.get_logger().error(f'Subtask {subtask.id} failed')

        # Add to failed tasks
        self.failed_tasks.append(subtask.id)

        # Try recovery procedures
        for recovery_proc in subtask.recovery_procedures:
            if self.execute_recovery_procedure(recovery_proc, subtask):
                # Recovery succeeded, retry the task
                self.get_logger().info(f'Recovery procedure succeeded, retrying task {subtask.id}')
                self.execute_subtask(subtask)
                return

        # If all recovery attempts fail, escalate
        self.escalate_failure(subtask)

    def execute_recovery_procedure(self, procedure: str, failed_task: SubTask) -> bool:
        """Execute a recovery procedure"""
        self.get_logger().info(f'Attempting recovery procedure: {procedure}')

        if procedure == 'retry_with_different_approach':
            # Modify parameters and retry
            new_params = failed_task.parameters.copy()
            # Add variation to approach
            new_params['approach_angle'] = new_params.get('approach_angle', 0) + 0.2
            retry_task = SubTask(
                id=f"{failed_task.id}_retry",
                action_type=failed_task.action_type,
                parameters=new_params,
                estimated_duration=failed_task.estimated_duration,
                success_criteria=failed_task.success_criteria,
                recovery_procedures=failed_task.recovery_procedures
            )
            self.execute_subtask(retry_task)
            return True

        elif procedure == 'request_human_assistance':
            # Request help from human operator
            help_request = String()
            help_request.data = f"Need assistance with task: {failed_task.id}"
            help_pub = self.create_publisher(String, '/help_requests', 10)
            help_pub.publish(help_request)
            return True

        elif procedure == 'use_alternative_method':
            # Try alternative approach
            if failed_task.action_type == 'navigation':
                # Try a different path planning algorithm
                new_params = failed_task.parameters.copy()
                new_params['planner_type'] = 'alternative'
                retry_task = SubTask(
                    id=f"{failed_task.id}_alt",
                    action_type=failed_task.action_type,
                    parameters=new_params,
                    estimated_duration=failed_task.estimated_duration,
                    success_criteria=failed_task.success_criteria,
                    recovery_procedures=failed_task.recovery_procedures
                )
                self.execute_subtask(retry_task)
                return True

        return False

    def escalate_failure(self, failed_task: SubTask):
        """Escalate task failure to higher level"""
        self.get_logger().error(f'All recovery attempts failed for task {failed_task.id}')

        # Publish failure notification
        status_msg = String()
        status_msg.data = f"TASK_FAILED: {failed_task.id} - {failed_task.action_type}"
        self.status_pub.publish(status_msg)

        # If this was part of a larger plan, consider replanning
        if self.current_plan:
            self.consider_replanning(failed_task)

    def consider_replanning(self, failed_task: SubTask):
        """Consider replanning when a task fails"""
        self.get_logger().info('Considering replanning due to task failure')

        # For now, just log and continue with remaining tasks
        # In practice, this would call the LLM to generate an alternative plan
        remaining_tasks = [
            st for st in self.current_plan.subtasks
            if st.id not in self.completed_tasks and st.id != failed_task.id
        ]

        if remaining_tasks:
            self.get_logger().info(f'Continuing with {len(remaining_tasks)} remaining tasks')
        else:
            self.get_logger().info('No remaining tasks in plan')

    def update_robot_state_after_task(self, subtask: SubTask):
        """Update robot state after task completion"""
        if subtask.action_type == 'navigation':
            # Update location
            self.robot_state['location'].x = subtask.parameters.get('x', self.robot_state['location'].x)
            self.robot_state['location'].y = subtask.parameters.get('y', self.robot_state['location'].y)
            self.robot_state['location'].z = subtask.parameters.get('z', self.robot_state['location'].z)

        elif subtask.action_type == 'manipulation':
            if 'grasp' in subtask.action_type.lower():
                # Update gripper state
                hand = subtask.parameters.get('hand', 'right')
                self.robot_state['grippers'][hand] = 'occupied'
            elif 'place' in subtask.action_type.lower():
                # Update gripper state
                hand = subtask.parameters.get('hand', 'right')
                self.robot_state['grippers'][hand] = 'free'

    def task_status_callback(self, msg: String):
        """Handle task status updates from other nodes"""
        try:
            status_data = json.loads(msg.data)
            task_id = status_data.get('task_id')
            status = status_data.get('status')

            if task_id in self.active_tasks:
                if status == 'completed':
                    self.handle_subtask_success(self.active_tasks[task_id]['subtask'])
                elif status == 'failed':
                    self.handle_subtask_failure(self.active_tasks[task_id]['subtask'])

        except json.JSONDecodeError:
            self.get_logger().error(f'Invalid JSON in task status message: {msg.data}')

    def load_environment_knowledge(self):
        """Load known objects and locations from environment"""
        # In practice, this would come from semantic mapping or prior learning
        # For demonstration:
        self.known_objects = {
            'red_cup': {'type': 'container', 'location': 'kitchen_table', 'properties': {'color': 'red', 'contains': 'water'}},
            'blue_bottle': {'type': 'container', 'location': 'counter', 'properties': {'color': 'blue', 'contains': 'juice'}},
            'chair_1': {'type': 'furniture', 'location': 'dining_room', 'properties': {'material': 'wood', 'occupiable': True}},
            'book': {'type': 'document', 'location': 'shelf', 'properties': {'title': 'Robotics Handbook', 'author': 'Expert'}}
        }

        self.known_locations = {
            'kitchen': {'coordinates': {'x': 5.0, 'y': 2.0}, 'contents': ['red_cup']},
            'living_room': {'coordinates': {'x': 0.0, 'y': 0.0}, 'contents': ['chair_1']},
            'dining_room': {'coordinates': {'x': 3.0, 'y': 1.0}, 'contents': ['chair_1']},
            'office': {'coordinates': {'x': -2.0, 'y': 1.0}, 'contents': ['book']},
            'entrance': {'coordinates': {'x': 0.0, 'y': -5.0}, 'contents': []}
        }

    def simulate_perception_task(self, object_name: str, search_area: str) -> bool:
        """Simulate perception task (in practice, this would call actual perception nodes)"""
        # Check if object is known
        if object_name in self.known_objects:
            # Object exists, return success
            return True

        # Object not known, might need to search
        # In practice, this would trigger object detection in the specified area
        return False

class PlanValidator:
    """Validates plans generated by LLMs"""
    def __init__(self, robot_capabilities: Dict[str, Any]):
        self.capabilities = robot_capabilities

    def validate_plan(self, plan: TaskPlan) -> Tuple[bool, List[str]]:
        """Validate a plan for feasibility"""
        issues = []

        # Check if robot can physically perform all actions
        for subtask in plan.subtasks:
            if not self.validate_subtask(subtask):
                issues.append(f"Subtask {subtask.id} not feasible with robot capabilities")

        # Check for logical consistency
        if not self.check_logical_consistency(plan):
            issues.append("Plan has logical inconsistencies")

        # Check resource constraints
        if not self.check_resource_constraints(plan):
            issues.append("Plan exceeds resource constraints")

        return len(issues) == 0, issues

    def validate_subtask(self, subtask: SubTask) -> bool:
        """Validate if a subtask is feasible"""
        if subtask.action_type == 'manipulation':
            # Check if object is graspable
            object_weight = subtask.parameters.get('weight', 1.0)
            if object_weight > self.capabilities.get('max_lift_weight', 5.0):
                return False

        elif subtask.action_type == 'navigation':
            # Check if destination is reachable
            distance = self.calculate_distance(subtask.parameters)
            max_range = self.capabilities.get('max_navigation_range', 10.0)
            if distance > max_range:
                return False

        return True

    def check_logical_consistency(self, plan: TaskPlan) -> bool:
        """Check if plan is logically consistent"""
        # Check for contradictory subtasks
        # Check for circular dependencies
        # Check if preconditions are met
        return True  # Simplified for example

    def check_resource_constraints(self, plan: TaskPlan) -> bool:
        """Check if plan respects resource constraints"""
        total_time = sum(st.estimated_duration for st in plan.subtasks)
        max_time = self.capabilities.get('max_operation_time', 3600.0)  # 1 hour

        if total_time > max_time:
            return False

        return True

    def calculate_distance(self, params: Dict[str, Any]) -> float:
        """Calculate distance for navigation tasks"""
        x = params.get('x', 0.0)
        y = params.get('y', 0.0)
        return (x**2 + y**2)**0.5

# Example usage
def main(args=None):
    rclpy.init(args=args)
    node = CognitivePlannerNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## ROS 2 Action Orchestration

Integrating LLM-based planning with ROS 2 action architecture:

```python
import rclpy
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from std_msgs.msg import String
from action_msgs.msg import GoalStatus
from geometry_msgs.msg import PoseStamped
import json
from typing import Optional

class HierarchicalActionServer:
    """Action server that orchestrates complex tasks using LLM planning"""
    def __init__(self, node: CognitivePlannerNode):
        self.node = node
        self.goal_handle = None

        # Create action server
        self.action_server = ActionServer(
            node,
            ComplexTask,
            'complex_task_executor',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup()
        )

    def goal_callback(self, goal_request):
        """Accept or reject goal requests"""
        self.node.get_logger().info(f'Received complex task request: {goal_request.description}')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Accept or reject cancel requests"""
        self.node.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute the complex task"""
        self.node.get_logger().info('Executing complex task...')
        feedback_msg = ComplexTask.Feedback()
        result = ComplexTask.Result()

        try:
            # Generate plan using LLM
            plan = self.node.generate_plan_with_llm(goal_handle.request.description)
            if not plan:
                result.success = False
                result.message = "Failed to generate plan"
                goal_handle.abort()
                return result

            # Execute plan
            for i, subtask in enumerate(plan.subtasks):
                # Check if goal was cancelled
                if goal_handle.is_cancel_requested:
                    result.success = False
                    result.message = "Goal cancelled"
                    goal_handle.canceled()
                    return result

                # Update feedback
                feedback_msg.current_subtask = subtask.id
                feedback_msg.progress = (i + 1) / len(plan.subtasks)
                goal_handle.publish_feedback(feedback_msg)

                # Execute subtask
                self.node.execute_subtask(subtask)

                # Wait for subtask completion
                # In practice, this would be more sophisticated
                self.node.get_clock().sleep_for(Duration(seconds=1.0))

            # All subtasks completed
            result.success = True
            result.message = f"Completed {len(plan.subtasks)} subtasks"
            goal_handle.succeed()
            self.node.get_logger().info('Complex task completed successfully')

        except Exception as e:
            self.node.get_logger().error(f'Error executing complex task: {e}')
            result.success = False
            result.message = f"Execution error: {str(e)}"
            goal_handle.abort()

        return result

# Custom action message (would be defined in .action file)
"""
# ComplexTask.action
string description
---
bool success
string message
---
string current_subtask
float32 progress
"""
from action_msgs.msg import GoalStatus
from rclpy.duration import Duration

class ComplexTask:
    class Goal:
        def __init__(self):
            self.description = ""

    class Result:
        def __init__(self):
            self.success = False
            self.message = ""

    class Feedback:
        def __init__(self):
            self.current_subtask = ""
            self.progress = 0.0

# Error Recovery Mechanisms
class ErrorRecoveryManager:
    """Manages error recovery for LLM-based cognitive planning"""
    def __init__(self, cognitive_planner: CognitivePlannerNode):
        self.planner = cognitive_planner
        self.recovery_strategies = self.define_recovery_strategies()

    def define_recovery_strategies(self) -> Dict[str, callable]:
        """Define various recovery strategies"""
        return {
            'retry': self.retry_strategy,
            'alternative_approach': self.alternative_approach_strategy,
            'human_intervention': self.human_intervention_strategy,
            'task_decomposition': self.task_decomposition_strategy,
            'resource_reallocation': self.resource_reallocation_strategy,
            'plan_revision': self.plan_revision_strategy
        }

    def handle_error(self, error_type: str, context: Dict[str, Any]) -> bool:
        """Handle an error using appropriate strategy"""
        if error_type in self.recovery_strategies:
            strategy = self.recovery_strategies[error_type]
            return strategy(context)
        else:
            self.planner.get_logger().error(f'No recovery strategy for error type: {error_type}')
            return False

    def retry_strategy(self, context: Dict[str, Any]) -> bool:
        """Simple retry strategy"""
        task = context.get('failed_task')
        max_retries = context.get('max_retries', 3)
        current_retry = context.get('current_retry', 0)

        if current_retry < max_retries:
            self.planner.get_logger().info(f'Retrying task {task.id}, attempt {current_retry + 1}')
            context['current_retry'] = current_retry + 1
            self.planner.execute_subtask(task)
            return True

        return False

    def alternative_approach_strategy(self, context: Dict[str, Any]) -> bool:
        """Try an alternative approach to the same goal"""
        task = context.get('failed_task')
        self.planner.get_logger().info(f'Trying alternative approach for task {task.id}')

        # Generate alternative plan using LLM
        alternative_plan = self.generate_alternative_plan(task, context)
        if alternative_plan:
            self.planner.execute_subtask(alternative_plan)
            return True

        return False

    def human_intervention_strategy(self, context: Dict[str, Any]) -> bool:
        """Request human intervention"""
        task = context.get('failed_task')
        error_details = context.get('error_details', '')

        self.planner.get_logger().info(f'Requesting human intervention for task {task.id}')

        # Publish help request
        help_msg = String()
        help_msg.data = f"Human assistance needed: Task {task.id} failed. Error: {error_details}"
        help_pub = self.planner.create_publisher(String, '/help_requests', 10)
        help_pub.publish(help_msg)

        return True

    def task_decomposition_strategy(self, context: Dict[str, Any]) -> bool:
        """Decompose failed task into smaller subtasks"""
        task = context.get('failed_task')
        self.planner.get_logger().info(f'Decomposing task {task.id} into smaller tasks')

        # Ask LLM to break down the task
        decomposition_prompt = f"""
        The following task failed: {task.description}
        Task parameters: {task.parameters}
        Error context: {context.get('error_details', 'Unknown error')}

        Please decompose this task into smaller, more manageable subtasks that are less likely to fail.
        Provide the decomposition in the same format as the original task.
        """

        try:
            response = self.planner.llm_client.chat.completions.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": "You are a task decomposition expert for robotics."},
                    {"role": "user", "content": decomposition_prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )

            decomposition = json.loads(response.choices[0].message.content)

            # Execute decomposed tasks
            for subtask_data in decomposition.get('subtasks', []):
                subtask = self.planner.json_to_subtask(subtask_data)
                self.planner.execute_subtask(subtask)

            return True

        except Exception as e:
            self.planner.get_logger().error(f'Error in task decomposition: {e}')
            return False

    def plan_revision_strategy(self, context: Dict[str, Any]) -> bool:
        """Revise the overall plan based on failure"""
        failed_task = context.get('failed_task')
        current_plan = context.get('current_plan')

        self.planner.get_logger().info('Revising overall plan due to task failure')

        # Generate new plan that accounts for the failure
        revision_prompt = f"""
        The following task failed: {failed_task.description}
        Original plan: {current_plan.description if current_plan else 'Unknown'}
        Error context: {context.get('error_details', 'Unknown error')}

        Please generate a revised plan that achieves the same overall goal but avoids the failure mode.
        Consider alternative approaches, different sequences, or modified parameters.
        """

        try:
            response = self.planner.llm_client.chat.completions.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": "You are a plan revision expert for robotics."},
                    {"role": "user", "content": revision_prompt}
                ],
                temperature=0.4,
                response_format={"type": "json_object"}
            )

            revised_plan_data = json.loads(response.choices[0].message.content)
            revised_plan = self.planner.json_to_task_plan(revised_plan_data)

            # Execute the revised plan
            self.planner.current_plan = revised_plan
            self.planner.execute_plan(revised_plan)

            return True

        except Exception as e:
            self.planner.get_logger().error(f'Error in plan revision: {e}')
            return False

    def generate_alternative_plan(self, task: SubTask, context: Dict[str, Any]) -> Optional[SubTask]:
        """Generate an alternative approach to the same goal"""
        # In practice, this would call the LLM to generate alternative approaches
        # For now, return a modified version of the original task
        return SubTask(
            id=f"{task.id}_alt",
            action_type=task.action_type,
            parameters=self.modify_parameters_for_alternative(task.parameters),
            estimated_duration=task.estimated_duration,
            success_criteria=task.success_criteria,
            recovery_procedures=task.recovery_procedures
        )

    def modify_parameters_for_alternative(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Modify parameters to create an alternative approach"""
        new_params = parameters.copy()

        # Example modifications:
        # - Change approach angle
        # - Use different hand/arm
        # - Increase safety margins
        # - Use different tool/object

        if 'approach_angle' in new_params:
            new_params['approach_angle'] += 0.3  # Different angle
        elif 'hand' in new_params:
            # Switch hands if available
            if new_params['hand'] == 'right':
                new_params['hand'] = 'left'
            else:
                new_params['hand'] = 'right'

        # Add safety margin
        if 'safety_margin' in new_params:
            new_params['safety_margin'] *= 1.5
        else:
            new_params['safety_margin'] = 0.1

        return new_params

# Tool-Using Agents
class ToolUsingAgent:
    """An agent that can use tools based on LLM reasoning"""
    def __init__(self, cognitive_planner: CognitivePlannerNode):
        self.planner = cognitive_planner
        self.available_tools = self.register_tools()
        self.tool_usage_history = []

    def register_tools(self) -> Dict[str, callable]:
        """Register available tools that the agent can use"""
        return {
            'navigation_tool': self.navigation_tool,
            'object_detection_tool': self.object_detection_tool,
            'grasping_tool': self.grasping_tool,
            'manipulation_tool': self.manipulation_tool,
            'communication_tool': self.communication_tool,
            'state_query_tool': self.state_query_tool,
            'environment_mapping_tool': self.environment_mapping_tool,
            'battery_check_tool': self.battery_check_tool
        }

    def navigation_tool(self, **kwargs) -> Dict[str, Any]:
        """Tool for navigation"""
        target_x = kwargs.get('x', 0.0)
        target_y = kwargs.get('y', 0.0)
        target_z = kwargs.get('z', 0.0)

        # Create and execute navigation subtask
        nav_subtask = SubTask(
            id=f"nav_to_{target_x}_{target_y}",
            action_type='navigation',
            parameters={'x': target_x, 'y': target_y, 'z': target_z},
            estimated_duration=30.0,
            success_criteria=['reached_destination'],
            recovery_procedures=['retry_with_different_path']
        )

        self.planner.execute_subtask(nav_subtask)

        return {
            'success': True,
            'result': f'Navigated to ({target_x}, {target_y}, {target_z})',
            'execution_time': 30.0
        }

    def object_detection_tool(self, **kwargs) -> Dict[str, Any]:
        """Tool for detecting objects"""
        object_name = kwargs.get('object_name', 'any')
        search_area = kwargs.get('search_area', 'current_view')

        # Simulate object detection
        detected = self.planner.simulate_perception_task(object_name, search_area)

        if detected and object_name in self.planner.known_objects:
            obj_info = self.planner.known_objects[object_name]
            return {
                'success': True,
                'result': f'Found {object_name} at {obj_info["location"]}',
                'object_info': obj_info
            }
        else:
            return {
                'success': False,
                'result': f'Could not find {object_name}',
                'object_info': None
            }

    def grasping_tool(self, **kwargs) -> Dict[str, Any]:
        """Tool for grasping objects"""
        object_name = kwargs.get('object_name')
        approach_distance = kwargs.get('approach_distance', 0.1)

        # Create and execute grasping subtask
        grasp_subtask = SubTask(
            id=f"grasp_{object_name}",
            action_type='manipulation',
            parameters={
                'object_name': object_name,
                'approach_distance': approach_distance,
                'grasp_type': kwargs.get('grasp_type', 'pinch')
            },
            estimated_duration=15.0,
            success_criteria=['object_grasped'],
            recovery_procedures=['retry_with_different_grasp', 'use_alternative_object']
        )

        self.planner.execute_subtask(grasp_subtask)

        return {
            'success': True,
            'result': f'Attempted to grasp {object_name}',
            'execution_time': 15.0
        }

    def communication_tool(self, **kwargs) -> Dict[str, Any]:
        """Tool for communication"""
        text = kwargs.get('text', 'Hello')
        recipient = kwargs.get('recipient', 'everyone')

        # Publish speech
        speech_pub = self.planner.create_publisher(String, '/tts_input', 10)
        speech_msg = String()
        speech_msg.data = text
        speech_pub.publish(speech_msg)

        return {
            'success': True,
            'result': f'Said: "{text}" to {recipient}',
            'execution_time': 2.0
        }

    def state_query_tool(self, **kwargs) -> Dict[str, Any]:
        """Tool for querying robot state"""
        requested_state = kwargs.get('state_property', 'all')

        if requested_state == 'all':
            return {
                'success': True,
                'result': self.planner.robot_state,
                'execution_time': 0.1
            }
        else:
            value = self.planner.robot_state.get(requested_state)
            return {
                'success': True,
                'result': {requested_state: value},
                'execution_time': 0.1
            }

    def use_tool(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """Use a registered tool"""
        if tool_name in self.available_tools:
            self.planner.get_logger().info(f'Using tool: {tool_name} with params: {kwargs}')

            try:
                result = self.available_tools[tool_name](**kwargs)

                # Log tool usage
                self.tool_usage_history.append({
                    'tool': tool_name,
                    'params': kwargs,
                    'result': result,
                    'timestamp': self.planner.get_clock().now().nanoseconds
                })

                return result
            except Exception as e:
                self.planner.get_logger().error(f'Error using tool {tool_name}: {e}')
                return {
                    'success': False,
                    'result': f'Error: {str(e)}',
                    'execution_time': 0.0
                }
        else:
            return {
                'success': False,
                'result': f'Unknown tool: {tool_name}',
                'execution_time': 0.0
            }

    def plan_with_tools(self, goal: str) -> Optional[TaskPlan]:
        """Generate a plan that utilizes available tools"""
        # Use LLM to determine which tools to use for the goal
        tool_selection_prompt = f"""
        Goal: {goal}

        Available tools:
        {list(self.available_tools.keys())}

        Robot capabilities and current state:
        {self.planner.robot_state}

        Known objects and locations:
        Objects: {list(self.planner.known_objects.keys())}
        Locations: {list(self.planner.known_locations.keys())}

        Please generate a plan that uses the appropriate tools to achieve the goal.
        For each step, specify which tool to use and with what parameters.
        Return the plan in JSON format with tool usage steps.
        """

        try:
            response = self.planner.llm_client.chat.completions.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": "You are a tool-using planning expert for robotics."},
                    {"role": "user", "content": tool_selection_prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )

            plan_data = json.loads(response.choices[0].message.content)

            # Convert to TaskPlan format
            subtasks = []
            for step in plan_data.get('steps', []):
                tool_name = step.get('tool')
                params = step.get('parameters', {})

                subtask = SubTask(
                    id=f"tool_{tool_name}_{len(subtasks)}",
                    action_type='tool_usage',
                    parameters={'tool_name': tool_name, 'tool_params': params},
                    estimated_duration=step.get('estimated_duration', 10.0),
                    success_criteria=step.get('success_criteria', ['tool_executed']),
                    recovery_procedures=step.get('recovery_procedures', ['retry_tool'])
                )

                subtasks.append(subtask)

            plan = TaskPlan(
                id=f"tool_based_plan_{len(self.tool_usage_history)}",
                description=f"Tool-based plan for: {goal}",
                subtasks=subtasks,
                dependencies=[],
                priority=1
            )

            return plan

        except Exception as e:
            self.planner.get_logger().error(f'Error in tool-based planning: {e}')
            return None

def main_with_tools(args=None):
    """Main function with tool integration"""
    rclpy.init(args=args)
    node = CognitivePlannerNode()

    # Initialize components
    error_manager = ErrorRecoveryManager(node)
    tool_agent = ToolUsingAgent(node)

    # Example: Use tools to achieve a complex goal
    goal = "Go to the kitchen, find the red cup, grasp it, and bring it to the living room"

    # Plan using tools
    tool_based_plan = tool_agent.plan_with_tools(goal)
    if tool_based_plan:
        node.get_logger().info(f'Executing tool-based plan with {len(tool_based_plan.subtasks)} steps')

        for subtask in tool_based_plan.subtasks:
            if 'tool_name' in subtask.parameters:
                tool_name = subtask.parameters['tool_name']
                tool_params = subtask.parameters.get('tool_params', {})

                result = tool_agent.use_tool(tool_name, **tool_params)
                node.get_logger().info(f'Tool result: {result}')

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main_with_tools()
```

## Practical Exercise

1. Implement LLM-based cognitive planning for a complex household task
2. Integrate ROS 2 action orchestration with the planning system
3. Design error recovery mechanisms for common failure modes
4. Create a tool-using agent that can perform multi-step tasks

## Summary

LLM-based cognitive planning provides high-level reasoning capabilities for humanoid robots, enabling complex task decomposition and execution. The system integrates with ROS 2 action architecture for reliable execution, implements robust error recovery mechanisms, and supports tool-using agents that can perform sophisticated multi-step tasks. This approach allows humanoid robots to interpret natural language commands, generate executable plans, and adapt to changing conditions and failures during execution.