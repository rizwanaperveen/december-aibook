---
sidebar_position: 3
---

# Chapter 1.3 â€“ Python Agents with rclpy

## Learning Objectives
- Create ROS 2 nodes using the rclpy library
- Implement publishing and subscribing patterns for robot control
- Develop action servers and clients for humanoid tasks
- Bridge AI logic with robot controllers using rclpy

## rclpy Node Creation

The `rclpy` library provides Python bindings for ROS 2. Here's the basic structure of a humanoid control agent:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import JointState
from control_msgs.msg import JointTrajectoryControllerState
import time

class HumanoidAgent(Node):
    def __init__(self):
        super().__init__('humanoid_agent')

        # Publishers for sending commands
        self.joint_cmd_pub = self.create_publisher(
            JointState,
            '/joint_commands',
            10
        )

        # Subscribers for receiving sensor data
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for control loop
        self.control_timer = self.create_timer(
            0.01,  # 100Hz control loop
            self.control_loop
        )

        self.get_logger().info('Humanoid Agent initialized')

    def joint_state_callback(self, msg: JointState):
        """Process incoming joint state messages"""
        self.get_logger().info(f'Received {len(msg.position)} joint positions')
        # Process sensor data for control decisions

    def control_loop(self):
        """Main control loop for humanoid agent"""
        # Implement control logic here
        self.get_logger().debug('Control loop executing')

def main(args=None):
    rclpy.init(args=args)

    agent = HumanoidAgent()

    try:
        rclpy.spin(agent)
    except KeyboardInterrupt:
        pass
    finally:
        agent.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Publishing and Subscribing

### Publishing Joint Commands

For humanoid robots, publishing joint commands requires careful attention to timing and safety:

```python
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration

class JointCommander(Node):
    def __init__(self):
        super().__init__('joint_commander')
        self.traj_pub = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

    def send_joint_trajectory(self, joint_names, positions, velocities=None, duration=1.0):
        """Send a joint trajectory command"""
        traj_msg = JointTrajectory()
        traj_msg.joint_names = joint_names

        point = JointTrajectoryPoint()
        point.positions = positions
        point.velocities = velocities if velocities else [0.0] * len(positions)
        point.time_from_start = Duration(sec=int(duration), nanosec=(duration % 1) * 1e9)

        traj_msg.points = [point]

        self.traj_pub.publish(traj_msg)
        self.get_logger().info(f'Sent trajectory for joints: {joint_names}')

# Example usage for humanoid joints
def move_to_home_position(self):
    joint_names = [
        'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',
        'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',
        'left_shoulder_joint', 'left_elbow_joint',
        'right_shoulder_joint', 'right_elbow_joint'
    ]

    home_positions = [0.0] * len(joint_names)  # All joints to zero position
    self.send_joint_trajectory(joint_names, home_positions, duration=2.0)
```

### Subscribing to Sensor Data

Humanoid robots require multiple sensor streams with appropriate QoS settings:

```python
from sensor_msgs.msg import Imu, JointState
from geometry_msgs.msg import Twist

class SensorProcessor(Node):
    def __init__(self):
        super().__init__('sensor_processor')

        # IMU for balance control (high frequency, best effort)
        self.imu_sub = self.create_subscription(
            Imu,
            '/imu/data',
            self.imu_callback,
            1,  # Keep only latest
            # Use best effort for performance
            qos_profile=rclpy.qos.qos_profile_sensor_data
        )

        # Joint states (reliable, with history)
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_callback,
            10  # Keep 10 messages in history
        )

        # Store latest sensor data
        self.latest_imu = None
        self.latest_joints = None

    def imu_callback(self, msg: Imu):
        """Process IMU data for balance control"""
        self.latest_imu = {
            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],
            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],
            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]
        }

        # Trigger balance control if needed
        self.check_balance()

    def joint_callback(self, msg: JointState):
        """Process joint state data"""
        self.latest_joints = dict(zip(msg.name, msg.position))

        # Check for joint limits or errors
        self.validate_joints()

    def check_balance(self):
        """Simple balance check based on IMU data"""
        if self.latest_imu:
            roll, pitch, yaw = self.quaternion_to_euler(self.latest_imu['orientation'])
            if abs(roll) > 0.5 or abs(pitch) > 0.5:  # Threshold for balance error
                self.get_logger().warn('Balance error detected!')
                # Trigger recovery behavior

    def quaternion_to_euler(self, q):
        """Convert quaternion to Euler angles (simplified)"""
        import math
        # Simplified conversion - in practice, use tf_transformations or similar
        sinr_cosp = 2 * (q[3] * q[0] + q[1] * q[2])
        cosr_cosp = 1 - 2 * (q[0] * q[0] + q[1] * q[1])
        roll = math.atan2(sinr_cosp, cosr_cosp)

        sinp = 2 * (q[3] * q[1] - q[2] * q[0])
        pitch = math.asin(sinp)

        siny_cosp = 2 * (q[3] * q[2] + q[0] * q[1])
        cosy_cosp = 1 - 2 * (q[1] * q[1] + q[2] * q[2])
        yaw = math.atan2(siny_cosp, cosy_cosp)

        return roll, pitch, yaw