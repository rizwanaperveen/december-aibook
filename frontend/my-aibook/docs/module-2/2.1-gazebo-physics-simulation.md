---
sidebar_position: 1
---

# Chapter 2.1: Gazebo Physics Simulation

## Learning Objectives
- Configure realistic physics for humanoid robots
- Implement sensor simulation with proper noise models
- Set up terrain and environment simulation
- Validate simulation accuracy with real-world comparisons

## Physics Engine Configuration

Gazebo provides multiple physics engines optimized for different simulation scenarios. For humanoid robots, we need to configure the physics engine to accurately simulate bipedal locomotion:

```xml
<!-- gazebo_world.physics -->
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Physics engine configuration -->
    <physics type="ode" name="default_physics">
      <max_step_size>0.001</max_step_size>  <!-- 1ms time step for accuracy -->
      <real_time_factor>1.0</real_time_factor>  <!-- Real-time simulation -->
      <real_time_update_rate>1000</real_time_update_rate>  <!-- 1000 Hz update rate -->

      <!-- ODE-specific parameters -->
      <ode>
        <solver>
          <type>quick</type>  <!-- Quick solver for performance -->
          <iters>100</iters>  <!-- Iterations for constraint solving -->
          <sor>1.3</sor>  <!-- Successive Over-Relaxation parameter -->
        </solver>
        <constraints>
          <cfm>0.0</cfm>  <!-- Constraint Force Mixing -->
          <erp>0.2</erp>  <!-- Error Reduction Parameter -->
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>  <!-- Penetration allowance -->
        </constraints>
      </ode>
    </physics>

    <!-- Gravity -->
    <gravity>0 0 -9.8</gravity>

    <!-- Wind effects (optional) -->
    <wind>
      <linear_velocity>0 0 0</linear_velocity>
    </wind>
  </world>
</sdf>
```

### Humanoid-Specific Physics Parameters

For humanoid robots, special attention must be paid to parameters that affect balance and locomotion:

```xml
<!-- Physics parameters optimized for humanoid simulation -->
<physics type="ode" name="humanoid_physics">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>0.8</real_time_factor>  <!-- Slightly slower for stability -->
  <real_time_update_rate>1000</real_time_update_rate>

  <ode>
    <solver>
      <type>quick</type>
      <iters>200</iters>  <!-- More iterations for humanoid stability -->
      <sor>1.0</sor>  <!-- Conservative SOR for stability -->
    </solver>
    <constraints>
      <cfm>1e-5</cfm>  <!-- Lower CFM for tighter constraints -->
      <erp>0.1</erp>  <!-- Lower ERP for better error correction -->
      <contact_max_correcting_vel>10.0</contact_max_correcting_vel>
      <contact_surface_layer>0.002</contact_surface_layer>  <!-- Slightly higher for foot contacts -->
    </constraints>
  </ode>
</physics>
```

## Contact Materials and Friction

Proper contact modeling is crucial for humanoid balance and walking:

```xml
<!-- Material properties for humanoid robot -->
<gazebo reference="humanoid_robot">
  <!-- Define materials with appropriate friction coefficients -->
  <material name="rubber_foot">
    <pbr>
      <metal>
        <albedo_map>file://materials/textures/rubber.png</albedo_map>
        <roughness>0.8</roughness>
        <metalness>0.0</metalness>
      </metal>
    </pbr>
  </material>
</gazebo>

<!-- Foot link with high friction -->
<gazebo reference="left_foot_link">
  <collision name="foot_collision">
    <surface>
      <friction>
        <ode>
          <mu>0.8</mu>  <!-- High friction for stability -->
          <mu2>0.8</mu2>
          <slip1>0.0</slip1>  <!-- No slip for stable stance -->
          <slip2>0.0</slip2>
        </ode>
        <torsional>
          <coefficient>0.8</coefficient>
          <use_patch_radius>false</use_patch_radius>
          <surface_radius>0.02</surface_radius>
        </torsional>
      </friction>
      <contact>
        <ode>
          <soft_cfm>0.001</soft_cfm>
          <soft_erp>0.9</soft_erp>
          <kp>1e5</kp>  <!-- High stiffness for foot contacts -->
          <kd>100</kd>
          <max_vel>100.0</max_vel>
          <min_depth>0.001</min_depth>
        </ode>
      </contact>
    </surface>
  </collision>
</gazebo>

<!-- Body links with moderate friction -->
<gazebo reference="torso_link">
  <collision name="torso_collision">
    <surface>
      <friction>
        <ode>
          <mu>0.3</mu>  <!-- Moderate friction for body contacts -->
          <mu2>0.3</mu2>
        </ode>
      </friction>
    </surface>
  </collision>
</gazebo>
```

## Sensor Simulation with Noise Models

Accurate sensor simulation with proper noise models is essential for robust controller development:

```xml
<!-- IMU sensor with realistic noise -->
<gazebo reference="head_link">
  <sensor name="imu_sensor" type="imu">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <pose>0.05 0 0.05 0 0 0</pose>  <!-- Offset from link origin -->
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>  <!-- 0.2 mrad/s -->
            <bias_mean>0.0</bias_mean>
            <bias_stddev>0.0000075</bias_stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
            <bias_mean>0.0</bias_mean>
            <bias_stddev>0.0000075</bias_stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
            <bias_mean>0.0</bias_mean>
            <bias_stddev>0.0000075</bias_stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>  <!-- 17 mg -->
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>
    <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">
      <ros>
        <namespace>/humanoid</namespace>
        <remapping>~/out:=imu/data</remapping>
      </ros>
      <update_rate>100</update_rate>
      <topic_name>imu/data</topic_name>
      <frame_name>head_imu_link</frame_name>
      <initial_orientation_as_reference>false</initial_orientation_as_reference>
    </plugin>
  </sensor>
</gazebo>

<!-- Depth camera with noise -->
<gazebo reference="head_link">
  <sensor name="rgbd_camera" type="depth">
    <always_on>true</always_on>
    <update_rate>30</update_rate>
    <pose>0.1 0 0.05 0 0 0</pose>
    <camera name="head_camera">
      <horizontal_fov>1.047</horizontal_fov>  <!-- 60 degrees -->
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>10.0</far>
      </clip>
      <noise>
        <type>gaussian</type>
        <mean>0.0</mean>
        <stddev>0.007</stddev>
      </noise>
    </camera>
    <plugin name="camera_controller" filename="libgazebo_ros_openni_kinect.so">
      <alwaysOn>true</alwaysOn>
      <updateRate>30.0</updateRate>
      <cameraName>head_camera</cameraName>
      <imageTopicName>rgb/image_raw</imageTopicName>
      <depthImageTopicName>depth/image_raw</depthImageTopicName>
      <pointCloudTopicName>depth/points</pointCloudTopicName>
      <cameraInfoTopicName>rgb/camera_info</cameraInfoTopicName>
      <depthImageCameraInfoTopicName>depth/camera_info</depthImageCameraInfoName>
      <frameName>head_camera_depth_optical_frame</frameName>
      <baseline>0.1</baseline>
      <distortion_k1>0.0</distortion_k1>
      <distortion_k2>0.0</distortion_k2>
      <distortion_k3>0.0</distortion_k3>
      <distortion_t1>0.0</distortion_t1>
      <distortion_t2>0.0</distortion_t2>
      <pointCloudCutoff>0.5</pointCloudCutoff>
      <pointCloudCutoffMax>3.0</pointCloudCutoffMax>
      <CxPrime>0.0</CxPrime>
      <Cx>320.5</Cx>
      <Cy>240.5</Cy>
      <focalLength>320.0</focalLength>
      <hack_baseline>0.07</hack_baseline>
    </plugin>
  </sensor>
</gazebo>

<!-- LiDAR sensor -->
<gazebo reference="torso_link">
  <sensor name="lidar_2d" type="ray">
    <always_on>true</always_on>
    <update_rate>10</update_rate>
    <pose>0.0 0.0 0.3 0 0 0</pose>
    <ray>
      <scan>
        <horizontal>
          <samples>720</samples>
          <resolution>1</resolution>
          <min_angle>-3.14159</min_angle>  <!-- -π -->
          <max_angle>3.14159</max_angle>   <!-- π -->
        </horizontal>
      </scan>
      <range>
        <min>0.1</min>
        <max>10.0</max>
        <resolution>0.01</resolution>
      </range>
    </ray>
    <plugin name="lidar_controller" filename="libgazebo_ros_laser.so">
      <ros>
        <namespace>/humanoid</namespace>
        <remapping>scan:=scan_filtered</remapping>
      </ros>
      <output_type>sensor_msgs/LaserScan</output_type>
      <frame_name>lidar_link</frame_name>
      <topic_name>scan</topic_name>
    </plugin>
  </sensor>
</gazebo>
```

## Terrain and Environment Setup

Creating realistic environments for humanoid testing:

```xml
<!-- world_with_terrain.world -->
<sdf version="1.7">
  <world name="humanoid_terrain_world">
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Physics -->
    <physics type="ode" name="terrain_physics">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <ode>
        <solver>
          <type>quick</type>
          <iters>100</iters>
          <sor>1.3</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Terrain models -->
    <model name="uneven_terrain">
      <static>true</static>
      <link name="terrain_link">
        <collision name="terrain_collision">
          <geometry>
            <heightmap>
              <uri>file://terrain/uneven_heightmap.png</uri>
              <size>10 10 1</size>  <!-- width, depth, height -->
              <pos>0 0 0</pos>
            </heightmap>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.8</mu>
                <mu2>0.8</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="terrain_visual">
          <geometry>
            <heightmap>
              <uri>file://terrain/uneven_heightmap.png</uri>
              <size>10 10 1</size>
            </heightmap>
          </geometry>
        </visual>
        <inertial>
          <mass>1e10</mass>
          <inertia>
            <ixx>1e10</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>1e10</iyy>
            <iyz>0</iyz>
            <izz>1e10</izz>
          </inertia>
        </inertial>
      </link>
    </model>

    <!-- Stairs for testing locomotion -->
    <model name="stairs">
      <static>true</static>
      <link name="stairs_link">
        <collision name="stairs_collision">
          <geometry>
            <mesh>
              <uri>file://meshes/stairs.dae</uri>
            </mesh>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.9</mu>
                <mu2>0.9</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="stairs_visual">
          <geometry>
            <mesh>
              <uri>file://meshes/stairs.dae</uri>
            </mesh>
          </geometry>
        </visual>
        <inertial>
          <mass>1e10</mass>
          <inertia>
            <ixx>1e10</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>1e10</iyy>
            <iyz>0</iyz>
            <izz>1e10</izz>
          </inertia>
        </inertial>
      </link>
    </model>

    <!-- Obstacle course -->
    <model name="obstacle_1">
      <pose>2 0 0.1 0 0 0</pose>
      <link name="obstacle_link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.2 0.2 0.2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.2 0.2 0.2</size>
            </box>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Blue</name>
            </script>
          </material>
        </visual>
        <inertial>
          <mass>1.0</mass>
          <inertia>
            <ixx>0.0083</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.0083</iyy>
            <iyz>0</iyz>
            <izz>0.0083</izz>
          </inertia>
        </inertial>
      </link>
    </model>

    <!-- Humanoid robot -->
    <include>
      <uri>model://humanoid_robot</uri>
      <pose>0 0 0.8 0 0 0</pose>  <!-- Start above ground for stable placement -->
    </include>
  </world>
</sdf>
```

## Simulation Validation

Validating that the simulation accurately represents real-world physics:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu, JointState
from geometry_msgs.msg import PointStamped
from std_msgs.msg import Float64
import numpy as np
from scipy.spatial.transform import Rotation as R
import matplotlib.pyplot as plt

class SimulationValidator(Node):
    def __init__(self):
        super().__init__('simulation_validator')

        # Subscriptions for validation
        self.imu_sub = self.create_subscription(Imu, '/humanoid/imu/data', self.imu_callback, 10)
        self.joint_sub = self.create_subscription(JointState, '/joint_states', self.joint_callback, 10)

        # Publishers for validation metrics
        self.balance_error_pub = self.create_publisher(Float64, '/validation/balance_error', 10)
        self.energy_pub = self.create_publisher(Float64, '/validation/energy_consumption', 10)

        # Storage for validation data
        self.imu_data = []
        self.joint_data = []
        self.validation_metrics = {
            'balance_stability': [],
            'energy_efficiency': [],
            'tracking_accuracy': [],
            'contact_stability': []
        }

        # Reference values from real robot (when available)
        self.real_robot_reference = {
            'walking_speed': 0.5,  # m/s
            'step_frequency': 1.8,  # Hz
            'energy_per_meter': 150.0,  # J/m
            'balance_variance': 0.02  # rad^2
        }

        self.validation_timer = self.create_timer(0.1, self.validation_callback)

    def imu_callback(self, msg: Imu):
        """Process IMU data for validation"""
        # Convert quaternion to Euler angles
        quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]
        r = R.from_quat(quat)
        euler = r.as_euler('xyz')

        # Calculate balance metrics
        roll, pitch, yaw = euler

        # Zero Moment Point (ZMP) approximation
        com_height = 0.7  # Approximate CoM height for humanoid
        zmp_x = com_height * np.tan(pitch)
        zmp_y = com_height * np.tan(roll)

        # Balance error (deviation from center)
        balance_error = np.sqrt(zmp_x**2 + zmp_y**2)

        # Publish balance error
        error_msg = Float64()
        error_msg.data = float(balance_error)
        self.balance_error_pub.publish(error_msg)

        # Store for validation analysis
        self.imu_data.append({
            'timestamp': msg.header.stamp.sec + msg.header.stamp.nanosec * 1e-9,
            'roll': roll,
            'pitch': pitch,
            'yaw': yaw,
            'linear_acc': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z],
            'angular_vel': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],
            'balance_error': balance_error
        })

    def joint_callback(self, msg: JointState):
        """Process joint state data for validation"""
        # Calculate energy consumption approximation
        if hasattr(self, 'prev_joint_positions') and hasattr(self, 'prev_timestamp'):
            dt = msg.header.stamp.sec + msg.header.stamp.nanosec * 1e-9 - self.prev_timestamp

            if dt > 0:
                # Calculate joint velocities
                velocities = []
                for i, pos in enumerate(msg.position):
                    if i < len(self.prev_joint_positions):
                        vel = (pos - self.prev_joint_positions[i]) / dt
                        velocities.append(vel)
                    else:
                        velocities.append(0.0)

                # Approximate energy consumption (simplified model)
                # Energy = sum of (torque * velocity) over time
                # For now, use (velocity squared) as proxy
                approx_energy = sum(v**2 for v in velocities) * dt

                energy_msg = Float64()
                energy_msg.data = float(approx_energy)
                self.energy_pub.publish(energy_msg)

        # Store for validation
        self.joint_data.append({
            'timestamp': msg.header.stamp.sec + msg.header.stamp.nanosec * 1e-9,
            'positions': msg.position,
            'velocities': msg.velocity,
            'efforts': msg.effort
        })

        # Update previous values
        self.prev_joint_positions = msg.position[:]
        self.prev_timestamp = msg.header.stamp.sec + msg.header.stamp.nanosec * 1e-9

    def validation_callback(self):
        """Perform ongoing validation"""
        if len(self.imu_data) > 10:  # Need sufficient data
            # Calculate validation metrics
            balance_stability = self.calculate_balance_stability()
            energy_efficiency = self.calculate_energy_efficiency()
            contact_stability = self.calculate_contact_stability()

            # Store metrics
            self.validation_metrics['balance_stability'].append(balance_stability)
            self.validation_metrics['energy_efficiency'].append(energy_efficiency)
            self.validation_metrics['contact_stability'].append(contact_stability)

            # Log validation results
            self.get_logger().info(
                f'Validation - Balance: {balance_stability:.3f}, '
                f'Energy: {energy_efficiency:.3f}, '
                f'Contact: {contact_stability:.3f}'
            )

            # Check for significant deviations from expected behavior
            self.check_simulation_fidelity()

    def calculate_balance_stability(self) -> float:
        """Calculate balance stability metric"""
        if len(self.imu_data) < 10:
            return 0.0

        # Calculate variance of balance error (lower is better)
        balance_errors = [d['balance_error'] for d in self.imu_data[-50:]]  # Last 50 readings
        if len(balance_errors) > 1:
            stability = 1.0 / (1.0 + np.var(balance_errors))  # Higher is more stable
        else:
            stability = 1.0

        return stability

    def calculate_energy_efficiency(self) -> float:
        """Calculate energy efficiency metric"""
        if len(self.joint_data) < 10:
            return 0.0

        # Calculate average joint velocities (lower is more efficient)
        if len(self.joint_data) > 1:
            avg_velocities = []
            for i in range(len(self.joint_data[-1]['velocities'])):
                velocities = [jd['velocities'][i] for jd in self.joint_data[-20:]]
                if velocities:
                    avg_velocities.append(np.mean(np.abs(velocities)))

            if avg_velocities:
                avg_avg_velocity = np.mean(avg_velocities)
                # Higher efficiency for lower average velocities
                efficiency = 1.0 / (1.0 + avg_avg_velocity)
            else:
                efficiency = 1.0
        else:
            efficiency = 1.0

        return efficiency

    def calculate_contact_stability(self) -> float:
        """Calculate contact stability metric"""
        # This would involve checking contact forces and foot contacts
        # For simulation, we can approximate using IMU data
        if len(self.imu_data) < 10:
            return 0.0

        # Look for high frequency oscillations that indicate instability
        angular_velocities = []
        for d in self.imu_data[-20:]:
            ang_vel_mag = np.linalg.norm(d['angular_vel'])
            angular_velocities.append(ang_vel_mag)

        if len(angular_velocities) > 1:
            stability = 1.0 / (1.0 + np.std(angular_velocities))  # Lower std dev = more stable
        else:
            stability = 1.0

        return stability

    def check_simulation_fidelity(self):
        """Check if simulation behavior matches expected real-world behavior"""
        if len(self.validation_metrics['balance_stability']) < 100:
            return  # Need more data

        # Calculate recent averages
        recent_balance = np.mean(self.validation_metrics['balance_stability'][-50:])
        recent_energy = np.mean(self.validation_metrics['energy_efficiency'][-50:])
        recent_contact = np.mean(self.validation_metrics['contact_stability'][-50:])

        # Check for anomalies
        if recent_balance < 0.3:  # Very unstable
            self.get_logger().warn(f'High balance instability detected: {recent_balance:.3f}')
        if recent_energy < 0.3:  # Very inefficient
            self.get_logger().warn(f'Low energy efficiency detected: {recent_energy:.3f}')
        if recent_contact < 0.3:  # Unstable contacts
            self.get_logger().warn(f'Unstable contact dynamics detected: {recent_contact:.3f}')

    def generate_validation_report(self) -> str:
        """Generate a comprehensive validation report"""
        if not self.validation_metrics['balance_stability']:
            return "Insufficient data for validation report"

        report = "SIMULATION VALIDATION REPORT\n"
        report += "=" * 30 + "\n\n"

        # Balance stability
        avg_balance = np.mean(self.validation_metrics['balance_stability'])
        report += f"Balance Stability: {avg_balance:.3f}/1.0 (Higher is better)\n"

        # Energy efficiency
        avg_energy = np.mean(self.validation_metrics['energy_efficiency'])
        report += f"Energy Efficiency: {avg_energy:.3f}/1.0 (Higher is better)\n"

        # Contact stability
        avg_contact = np.mean(self.validation_metrics['contact_stability'])
        report += f"Contact Stability: {avg_contact:.3f}/1.0 (Higher is better)\n\n"

        # Recommendations
        report += "RECOMMENDATIONS:\n"
        if avg_balance < 0.5:
            report += "- Improve balance controller parameters\n"
        if avg_energy < 0.5:
            report += "- Optimize joint control for efficiency\n"
        if avg_contact < 0.5:
            report += "- Review contact parameters and friction\n"

        return report

def main(args=None):
    rclpy.init(args=args)
    validator = SimulationValidator()

    try:
        rclpy.spin(validator)
    except KeyboardInterrupt:
        # Generate final report
        report = validator.generate_validation_report()
        print(report)
    finally:
        validator.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Practical Exercise

1. Create a humanoid model with appropriate physics properties
2. Set up a challenging terrain environment
3. Implement sensor noise models that match real hardware
4. Validate simulation results against expected real-world behavior

## Summary

Physics simulation in Gazebo requires careful tuning of parameters for humanoid robots. Proper friction, contact models, and sensor noise are crucial for realistic simulation. The validation process ensures that simulated behavior matches expected real-world performance, enabling confidence in simulation-based development and testing.