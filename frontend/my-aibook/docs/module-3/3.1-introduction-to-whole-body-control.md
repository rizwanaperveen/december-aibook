# 3.1 Introduction to Whole Body Control

## Overview

Whole Body Control (WBC) represents a sophisticated approach to controlling multi-degree-of-freedom robotic systems, particularly humanoid robots. Unlike traditional joint-space control methods that address each joint independently, WBC considers the entire robot as an integrated system, optimizing the coordination of all actuators simultaneously to achieve multiple tasks with varying priorities. This chapter introduces the fundamental concepts, mathematical foundations, and practical implementations of whole body control for humanoid robotics.

## Learning Objectives

By the end of this chapter, you will be able to:
- Understand the fundamental principles of whole body control
- Explain the differences between joint-space control and task-space control
- Describe the mathematical foundations of optimization-based control
- Identify the key components of a whole body control system
- Analyze the advantages and challenges of whole body control approaches
- Implement basic whole body control algorithms for simple robotic tasks

## What is Whole Body Control?

Whole Body Control is a control framework that addresses the coordination of all degrees of freedom in a robotic system to achieve multiple simultaneous tasks. In humanoid robotics, this typically involves coordinating the movement of arms, legs, torso, and head to perform complex behaviors while maintaining balance and respecting physical constraints.

### Key Characteristics

1. **Multi-Task Optimization**: WBC handles multiple tasks simultaneously, each with its own priority level
2. **Constraint Handling**: Explicitly manages joint limits, torque limits, and contact constraints
3. **Hierarchical Priorities**: Organizes tasks in a hierarchy to ensure critical tasks (like balance) are prioritized
4. **Real-time Performance**: Designed for real-time control with fast computation requirements
5. **Constraint Satisfaction**: Ensures all physical and operational constraints are satisfied

### Comparison with Traditional Control Methods

Traditional robotic control typically operates in joint space, where each joint is controlled independently or in simple coordinated groups. In contrast, whole body control operates in task space, where the robot's behavior is defined by tasks in Cartesian space (position, orientation) or other meaningful coordinate systems.

```python
# Example: Joint-space control vs Task-space control
import numpy as np
from scipy.spatial.transform import Rotation as R

class JointSpaceController:
    """Traditional joint-space control approach"""
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.num_joints = robot_model.get_num_joints()

    def control_step(self, target_joints, current_joints, dt):
        """Simple joint-space PD control"""
        error = target_joints - current_joints
        velocity = error / dt
        # PD control: u = Kp * error + Kd * velocity
        control_effort = 100 * error + 10 * velocity
        return control_effort

class TaskSpaceController:
    """Task-space control approach"""
    def __init__(self, robot_model):
        self.robot_model = robot_model

    def control_step(self, target_tasks, current_tasks, dt):
        """Control based on task-space errors"""
        task_errors = []
        for target_task, current_task in zip(target_tasks, current_tasks):
            error = self.calculate_task_error(target_task, current_task)
            task_errors.append(error)

        # Map task-space errors to joint-space commands
        joint_commands = self.task_to_joint_mapping(task_errors)
        return joint_commands

    def calculate_task_error(self, target, current):
        """Calculate error in task space"""
        # For position tasks
        if hasattr(target, 'position'):
            pos_error = target.position - current.position
            return pos_error
        # For orientation tasks
        elif hasattr(target, 'orientation'):
            # Calculate orientation error using rotation matrices
            target_rot = R.from_quat(target.orientation)
            current_rot = R.from_quat(current.orientation)
            error_rot = target_rot * current_rot.inv()
            # Convert to axis-angle representation
            axis_angle = error_rot.as_rotvec()
            return axis_angle
        else:
            return target - current

    def task_to_joint_mapping(self, task_errors):
        """Map task-space errors to joint commands using Jacobian"""
        # This would involve computing the Jacobian matrix and its pseudo-inverse
        # J#d = desired_task_velocity
        # q#d = J# * x#d (where J# is pseudo-inverse of Jacobian)
        pass
```

## Mathematical Foundations

### Optimization Framework

Whole body control is fundamentally an optimization problem where multiple tasks are formulated as constraints or objectives in an optimization framework. The general form can be expressed as:

```
minimize: ||Ax - b||²
subject to: Cx = d (equality constraints)
           Ex ≤ f (inequality constraints)
```

Where:
- `x` is the vector of control variables (typically joint velocities or accelerations)
- `A` and `b` define the quadratic cost function
- `C` and `d` define equality constraints
- `E` and `f` define inequality constraints

### Hierarchical Optimization

In WBC, tasks are organized in a hierarchy of priorities. Higher priority tasks must be satisfied before lower priority tasks are considered. This is typically implemented using a lexicographic optimization approach:

```python
import numpy as np
from scipy.optimize import minimize, linprog
from typing import List, Tuple, Dict

class HierarchicalOptimizer:
    """Implements hierarchical optimization for whole body control"""

    def __init__(self):
        self.tasks = []
        self.constraints = []

    def add_task(self, task_matrix: np.ndarray, task_vector: np.ndarray,
                 priority: int, weight: float = 1.0):
        """Add a task to the optimization hierarchy"""
        task = {
            'A': task_matrix,
            'b': task_vector,
            'priority': priority,
            'weight': weight
        }
        self.tasks.append(task)
        # Sort tasks by priority
        self.tasks.sort(key=lambda x: x['priority'])

    def add_constraint(self, constraint_matrix: np.ndarray,
                      constraint_vector: np.ndarray, constraint_type: str = 'equality'):
        """Add constraint to the optimization problem"""
        constraint = {
            'A': constraint_matrix,
            'b': constraint_vector,
            'type': constraint_type
        }
        self.constraints.append(constraint)

    def solve_hierarchical(self, num_variables: int) -> np.ndarray:
        """Solve the hierarchical optimization problem"""
        # Start with highest priority task
        solution = np.zeros(num_variables)

        for task in self.tasks:
            # Formulate optimization problem for current priority level
            A = task['A']
            b = task['b']
            weight = task['weight']

            # Define objective function: minimize ||Ax - b||²
            def objective(x):
                return weight * np.sum((A @ x - b)**2)

            # Define constraints from higher priority tasks
            constraints = []
            for i, higher_task in enumerate(self.tasks[:self.tasks.index(task)]):
                # Add constraint that higher priority tasks must be satisfied
                higher_A = higher_task['A']
                higher_b = higher_task['b']
                # Constraint: ||higher_A @ x - higher_b||² ≈ 0
                constraints.append({
                    'type': 'eq',
                    'fun': lambda x, A=higher_A, b=higher_b: A @ x - b
                })

            # Add system constraints
            for constraint in self.constraints:
                if constraint['type'] == 'equality':
                    constraints.append({
                        'type': 'eq',
                        'fun': lambda x, A=constraint['A'], b=constraint['b']: A @ x - b
                    })

            # Solve optimization problem
            result = minimize(objective, solution, method='SLSQP', constraints=constraints)
            solution = result.x if result.success else solution

        return solution

# Example usage of hierarchical optimizer
def example_hierarchical_control():
    """Example of hierarchical whole body control"""
    optimizer = HierarchicalOptimizer()

    # Define system with 10 joints
    n_joints = 10

    # Task 1: Balance (highest priority)
    # Minimize deviation from center of mass
    balance_A = np.zeros((3, n_joints))  # 3D position of CoM
    balance_b = np.array([0.0, 0.0, 0.8])  # Desired CoM height and position
    optimizer.add_task(balance_A, balance_b, priority=1, weight=10.0)

    # Task 2: Arm reaching
    arm_A = np.zeros((6, n_joints))  # 6D pose of end-effector (position + orientation)
    arm_b = np.array([0.5, 0.2, 0.8, 0, 0, 0])  # Desired pose
    optimizer.add_task(arm_A, arm_b, priority=2, weight=5.0)

    # Task 3: Posture maintenance (lowest priority)
    posture_A = np.eye(n_joints)  # Identity matrix for joint positions
    posture_b = np.zeros(n_joints)  # Desired joint positions
    optimizer.add_task(posture_A, posture_b, priority=3, weight=1.0)

    # Solve the hierarchical optimization
    solution = optimizer.solve_hierarchical(n_joints)
    return solution
```

### Task Prioritization

Tasks in WBC are typically organized with the following priority structure:

1. **Level 1 (Highest)**: Equality constraints (kinematic constraints, contact constraints)
2. **Level 2**: Primary tasks (balance, safety)
3. **Level 3**: Secondary tasks (motion objectives)
4. **Level 4**: Optimization objectives (energy, smoothness)

## Core Components of Whole Body Control

### 1. Kinematic Model

The kinematic model describes the relationship between joint positions and end-effector positions. For whole body control, this includes forward and inverse kinematics for all kinematic chains.

```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class KinematicModel:
    """Kinematic model for whole body control"""

    def __init__(self, urdf_path: str):
        # In practice, this would load from URDF
        self.urdf_path = urdf_path
        self.joint_names = []
        self.links = []
        self.transforms = {}

    def forward_kinematics(self, joint_angles: np.ndarray,
                          end_effector_link: str) -> Dict[str, np.ndarray]:
        """Compute forward kinematics for end-effector"""
        # This would traverse the kinematic chain
        # For simplicity, we'll implement a basic version

        # Initialize transformation
        transform = np.eye(4)

        # Apply transformations for each joint
        for i, joint_angle in enumerate(joint_angles):
            # Create rotation matrix for revolute joint
            joint_transform = self._create_joint_transform(joint_angle, i)
            transform = transform @ joint_transform

        # Extract position and orientation
        position = transform[:3, 3]
        orientation_matrix = transform[:3, :3]
        orientation_quat = R.from_matrix(orientation_matrix).as_quat()

        return {
            'position': position,
            'orientation': orientation_quat,
            'transform': transform
        }

    def jacobian(self, joint_angles: np.ndarray,
                end_effector_link: str) -> np.ndarray:
        """Compute geometric Jacobian for end-effector"""
        # Geometric Jacobian maps joint velocities to end-effector twist
        # J = [J_v; J_w] where J_v is linear velocity Jacobian, J_w is angular velocity Jacobian

        n_joints = len(joint_angles)
        jacobian = np.zeros((6, n_joints))  # 6D twist (linear + angular)

        # Compute Jacobian columns
        for i in range(n_joints):
            # Get position of joint i
            joint_pos = self._get_joint_position(joint_angles[:i+1], i)

            # Get joint axis in world frame
            joint_axis = self._get_joint_axis(joint_angles[:i+1], i)

            # Linear velocity component: J_v_i = axis × (ee_pos - joint_pos)
            if self._is_revolute_joint(i):
                jacobian[:3, i] = np.cross(joint_axis, ee_pos - joint_pos)
                # Angular velocity component: J_w_i = axis
                jacobian[3:, i] = joint_axis
            else:  # Prismatic joint
                jacobian[:3, i] = joint_axis
                jacobian[3:, i] = np.zeros(3)

        return jacobian

    def _create_joint_transform(self, angle: float, joint_idx: int) -> np.ndarray:
        """Create transformation matrix for a joint"""
        # For a revolute joint around z-axis
        transform = np.eye(4)
        transform[0, 0] = np.cos(angle)
        transform[0, 1] = -np.sin(angle)
        transform[1, 0] = np.sin(angle)
        transform[1, 1] = np.cos(angle)
        return transform

    def _get_joint_position(self, joint_angles: np.ndarray, joint_idx: int) -> np.ndarray:
        """Get world position of a joint"""
        # Simplified implementation
        return np.array([0.0, 0.0, 0.0])

    def _get_joint_axis(self, joint_angles: np.ndarray, joint_idx: int) -> np.ndarray:
        """Get joint axis in world frame"""
        # Simplified implementation
        return np.array([0.0, 0.0, 1.0])

    def _is_revolute_joint(self, joint_idx: int) -> bool:
        """Check if joint is revolute"""
        return True
```

### 2. Dynamics Model

The dynamics model accounts for forces, torques, and inertial properties of the robot system.

```python
class DynamicsModel:
    """Dynamics model for whole body control"""

    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.mass_matrix = None
        self.coriolis_matrix = None
        self.gravity_vector = None

    def compute_mass_matrix(self, joint_positions: np.ndarray) -> np.ndarray:
        """Compute mass matrix (inertia matrix)"""
        # M(q) in the equation: M(q)q## + C(q,q#)q# + g(q) = τ
        # This would use the composite rigid body algorithm or other methods
        n_joints = len(joint_positions)
        mass_matrix = np.eye(n_joints) * 1.0  # Simplified diagonal matrix
        return mass_matrix

    def compute_coriolis_matrix(self, joint_positions: np.ndarray,
                               joint_velocities: np.ndarray) -> np.ndarray:
        """Compute Coriolis and centrifugal forces matrix"""
        # C(q,q#) in the dynamics equation
        n_joints = len(joint_positions)
        coriolis_matrix = np.zeros((n_joints, n_joints))
        # Simplified implementation - in practice, this involves Christoffel symbols
        return coriolis_matrix

    def compute_gravity_vector(self, joint_positions: np.ndarray) -> np.ndarray:
        """Compute gravity vector"""
        # g(q) in the dynamics equation
        n_joints = len(joint_positions)
        gravity_vector = np.zeros(n_joints)
        # Simplified implementation
        for i in range(n_joints):
            gravity_vector[i] = 9.81 * 0.1  # Simplified gravity effect
        return gravity_vector

    def inverse_dynamics(self, joint_positions: np.ndarray,
                        joint_velocities: np.ndarray,
                        joint_accelerations: np.ndarray) -> np.ndarray:
        """Compute required joint torques for desired accelerations"""
        # τ = M(q)q## + C(q,q#)q# + g(q)
        M = self.compute_mass_matrix(joint_positions)
        C = self.compute_coriolis_matrix(joint_positions, joint_velocities)
        g = self.compute_gravity_vector(joint_positions)

        torques = M @ joint_accelerations + C @ joint_velocities + g
        return torques

    def forward_dynamics(self, joint_positions: np.ndarray,
                        joint_velocities: np.ndarray,
                        applied_torques: np.ndarray) -> np.ndarray:
        """Compute joint accelerations from applied torques"""
        # q## = M#(q)[τ - C(q,q#)q# - g(q)]
        M = self.compute_mass_matrix(joint_positions)
        C = self.compute_coriolis_matrix(joint_positions, joint_velocities)
        g = self.compute_gravity_vector(joint_positions)

        # Compute accelerations
        M_inv = np.linalg.inv(M)
        accelerations = M_inv @ (applied_torques - C @ joint_velocities - g)
        return accelerations
```

### 3. Contact Model

For humanoid robots, contact with the environment (floor, objects) is crucial and must be properly modeled.

```python
class ContactModel:
    """Contact model for whole body control"""

    def __init__(self):
        self.contact_points = []
        self.contact_forces = []
        self.friction_coefficients = []

    def add_contact_point(self, position: np.ndarray, normal: np.ndarray,
                         friction_coeff: float = 0.8):
        """Add a contact point to the model"""
        contact = {
            'position': position,
            'normal': normal / np.linalg.norm(normal),  # Normalize
            'friction_coeff': friction_coeff,
            'active': True
        }
        self.contact_points.append(contact)
        self.friction_coefficients.append(friction_coeff)
        self.contact_forces.append(np.zeros(3))  # Initialize with zero force

    def compute_contact_jacobian(self, robot_model, contact_link: str) -> np.ndarray:
        """Compute Jacobian for contact point velocities"""
        # This maps joint velocities to contact point velocities
        # J_contact * q# = v_contact
        pass

    def check_contact_stability(self, com_position: np.ndarray,
                              contact_forces: np.ndarray) -> bool:
        """Check if contact configuration is stable"""
        # Check Zero Moment Point (ZMP) or support polygon
        if len(self.contact_points) == 0:
            return False

        # Calculate center of pressure
        total_force = np.sum(contact_forces, axis=0)
        if np.linalg.norm(total_force[:2]) < 1e-6:  # Very small horizontal force
            return True

        # Calculate moment about contact points
        moments = []
        for contact, force in zip(self.contact_points, contact_forces):
            # Moment = r × F
            r = contact['position'] - com_position
            moment = np.cross(r, force)
            moments.append(moment)

        # Check if net moment indicates stability
        net_moment = np.sum(moments, axis=0)
        # Simplified stability check
        return abs(net_moment[1]) < 0.1  # Small moment about y-axis (roll)

    def generate_contact_constraints(self) -> Tuple[np.ndarray, np.ndarray]:
        """Generate linear constraints for contact forces"""
        # For each contact point, generate friction cone constraints
        # These ensure contact forces lie within friction cones
        A_ineq = []
        b_ineq = []

        for i, contact in enumerate(self.contact_points):
            normal = contact['normal']
            mu = contact['friction_coeff']

            # Friction cone constraints: ||F_tangent|| ≤ μ * F_normal
            # This creates multiple linear inequality constraints
            # For 3D contact with 2D friction cone approximation
            # We'll create constraints for x and y components
            normal_force = normal[2]  # Assuming z is up

            # Constraint 1: F_x ≤ μ * F_normal
            row1 = np.zeros(len(self.contact_points) * 3)
            row1[i*3 + 0] = 1  # F_x coefficient
            row1[i*3 + 2] = -mu  # -μ * F_z coefficient
            A_ineq.append(row1)
            b_ineq.append(0)

            # Constraint 2: -F_x ≤ μ * F_normal (equivalently: F_x ≥ -μ * F_normal)
            row2 = np.zeros(len(self.contact_points) * 3)
            row2[i*3 + 0] = -1  # -F_x coefficient
            row2[i*3 + 2] = -mu  # -μ * F_z coefficient
            A_ineq.append(row2)
            b_ineq.append(0)

            # Constraint 3: F_y ≤ μ * F_normal
            row3 = np.zeros(len(self.contact_points) * 3)
            row3[i*3 + 1] = 1  # F_y coefficient
            row3[i*3 + 2] = -mu  # -μ * F_z coefficient
            A_ineq.append(row3)
            b_ineq.append(0)

            # Constraint 4: -F_y ≤ μ * F_normal
            row4 = np.zeros(len(self.contact_points) * 3)
            row4[i*3 + 1] = -1  # -F_y coefficient
            row4[i*3 + 2] = -mu  # -μ * F_z coefficient
            A_ineq.append(row4)
            b_ineq.append(0)

        return np.array(A_ineq), np.array(b_ineq)
```

## Implementation Example: Simple Whole Body Controller

Let's implement a simple but functional whole body controller that demonstrates the core concepts:

```python
import numpy as np
from scipy.optimize import minimize
from typing import List, Dict, Tuple
import time

class SimpleWholeBodyController:
    """A simple implementation of whole body control"""

    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.kinematic_model = KinematicModel("dummy.urdf")
        self.dynamics_model = DynamicsModel(robot_model)
        self.contact_model = ContactModel()

        # Control parameters
        self.control_frequency = 200  # Hz
        self.integration_dt = 1.0 / self.control_frequency

        # Task weights
        self.balance_weight = 100.0
        self.motion_weight = 10.0
        self.posture_weight = 1.0

        # Initialize joint positions
        self.current_joint_positions = np.zeros(robot_model.get_num_joints())
        self.current_joint_velocities = np.zeros(robot_model.get_num_joints())

        # Desired tasks
        self.desired_tasks = {
            'balance': {'position': np.array([0.0, 0.0, 0.8]), 'weight': 100.0},
            'left_arm': {'position': np.array([0.3, 0.2, 0.8]), 'weight': 10.0},
            'right_arm': {'position': np.array([0.3, -0.2, 0.8]), 'weight': 10.0}
        }

    def update(self, dt: float) -> np.ndarray:
        """Main control update function"""
        # Get current robot state
        current_positions = self.current_joint_positions
        current_velocities = self.current_joint_velocities

        # Solve whole body control optimization
        joint_accelerations = self._solve_control_problem(
            current_positions, current_velocities
        )

        # Integrate to get new velocities and positions
        new_velocities = current_velocities + joint_accelerations * dt
        new_positions = current_positions + new_velocities * dt

        # Update internal state
        self.current_joint_positions = new_positions
        self.current_joint_velocities = new_velocities

        return new_positions, new_velocities, joint_accelerations

    def _solve_control_problem(self, joint_positions: np.ndarray,
                             joint_velocities: np.ndarray) -> np.ndarray:
        """Solve the whole body control optimization problem"""
        n_joints = len(joint_positions)

        # Define the optimization problem
        def objective(joint_acc):
            """Objective function combining all tasks"""
            total_cost = 0.0

            # 1. Balance task - maintain center of mass
            com_pos = self._compute_com_position(joint_positions)
            com_vel = self._compute_com_velocity(joint_positions, joint_velocities)
            com_acc = self._compute_com_acceleration(joint_positions, joint_velocities, joint_acc)

            desired_com = self.desired_tasks['balance']['position']
            balance_error = com_pos - desired_com
            total_cost += self.balance_weight * np.sum(balance_error**2)

            # 2. End-effector tasks
            for effector_name in ['left_arm', 'right_arm']:
                if effector_name in self.desired_tasks:
                    ee_pos = self._compute_end_effector_position(joint_positions, effector_name)
                    desired_ee_pos = self.desired_tasks[effector_name]['position']
                    ee_error = ee_pos - desired_ee_pos
                    total_cost += self.motion_weight * np.sum(ee_error**2)

            # 3. Posture task - maintain desired joint configuration
            desired_posture = np.zeros(n_joints)  # Default posture
            posture_error = joint_positions - desired_posture
            total_cost += self.posture_weight * np.sum(posture_error**2)

            # 4. Smoothness term - penalize large accelerations
            total_cost += 0.1 * np.sum(joint_acc**2)

            return total_cost

        # Define constraints
        constraints = []

        # Joint limits constraints
        joint_limits = self.robot_model.get_joint_limits()
        for i in range(n_joints):
            # Lower bound: joint_acc[i] >= -max_acc
            constraints.append({
                'type': 'ineq',
                'fun': lambda acc, idx=i, max_acc=100: acc[idx] + max_acc
            })
            # Upper bound: joint_acc[i] <= max_acc
            constraints.append({
                'type': 'ineq',
                'fun': lambda acc, idx=i, max_acc=100: max_acc - acc[idx]
            })

        # Solve optimization problem
        initial_guess = np.zeros(n_joints)
        result = minimize(objective, initial_guess, method='SLSQP', constraints=constraints)

        if result.success:
            return result.x
        else:
            # Return zero acceleration if optimization fails
            return np.zeros(n_joints)

    def _compute_com_position(self, joint_positions: np.ndarray) -> np.ndarray:
        """Compute center of mass position"""
        # Simplified implementation
        # In practice, this would use the robot's inertial properties
        return np.array([0.0, 0.0, 0.8])  # Fixed CoM for demonstration

    def _compute_com_velocity(self, joint_positions: np.ndarray,
                            joint_velocities: np.ndarray) -> np.ndarray:
        """Compute center of mass velocity"""
        # Simplified implementation
        return np.array([0.0, 0.0, 0.0])

    def _compute_com_acceleration(self, joint_positions: np.ndarray,
                                joint_velocities: np.ndarray,
                                joint_accelerations: np.ndarray) -> np.ndarray:
        """Compute center of mass acceleration"""
        # Simplified implementation
        return np.array([0.0, 0.0, 0.0])

    def _compute_end_effector_position(self, joint_positions: np.ndarray,
                                     effector_name: str) -> np.ndarray:
        """Compute end-effector position using forward kinematics"""
        # This would call the kinematic model
        # For demonstration, return a fixed position
        if effector_name == 'left_arm':
            return np.array([0.3, 0.2, 0.8])
        elif effector_name == 'right_arm':
            return np.array([0.3, -0.2, 0.8])
        else:
            return np.array([0.0, 0.0, 0.0])

    def set_balance_task(self, desired_com_position: np.ndarray):
        """Set desired center of mass position for balance"""
        self.desired_tasks['balance']['position'] = desired_com_position

    def set_end_effector_task(self, effector_name: str, desired_position: np.ndarray):
        """Set desired end-effector position"""
        if effector_name in self.desired_tasks:
            self.desired_tasks[effector_name]['position'] = desired_position
        else:
            self.desired_tasks[effector_name] = {'position': desired_position, 'weight': 10.0}

    def add_contact(self, position: np.ndarray, normal: np.ndarray, friction_coeff: float = 0.8):
        """Add contact point to the controller"""
        self.contact_model.add_contact_point(position, normal, friction_coeff)

# Example usage and demonstration
def demonstrate_wbc():
    """Demonstrate whole body control concepts"""

    # Create a dummy robot model (in practice, this would interface with a real robot)
    class DummyRobotModel:
        def __init__(self):
            self.num_joints = 28  # Typical humanoid robot

        def get_num_joints(self):
            return self.num_joints

        def get_joint_limits(self):
            return {'lower': np.full(self.num_joints, -2.0),
                   'upper': np.full(self.num_joints, 2.0)}

    # Initialize the controller
    robot_model = DummyRobotModel()
    wbc_controller = SimpleWholeBodyController(robot_model)

    print("Whole Body Controller initialized")
    print(f"Robot has {robot_model.get_num_joints()} joints")
    print(f"Control frequency: {wbc_controller.control_frequency} Hz")

    # Set some tasks
    wbc_controller.set_balance_task(np.array([0.0, 0.0, 0.85]))
    wbc_controller.set_end_effector_task('left_arm', np.array([0.4, 0.3, 0.8]))
    wbc_controller.set_end_effector_task('right_arm', np.array([0.4, -0.3, 0.8]))

    # Add contact points (feet)
    wbc_controller.add_contact(np.array([0.1, 0.05, 0.0]), np.array([0, 0, 1]), 0.8)
    wbc_controller.add_contact(np.array([0.1, -0.05, 0.0]), np.array([0, 0, 1]), 0.8)

    print("Tasks and contacts set up")
    print("Balance task: maintain CoM at [0.0, 0.0, 0.85]")
    print("Left arm task: reach to [0.4, 0.3, 0.8]")
    print("Right arm task: reach to [0.4, -0.3, 0.8]")

    # Simulate control loop
    dt = 1.0 / wbc_controller.control_frequency
    simulation_steps = 100

    print(f"\nRunning simulation for {simulation_steps} steps...")

    for i in range(simulation_steps):
        # Update controller
        positions, velocities, accelerations = wbc_controller.update(dt)

        # Print progress every 20 steps
        if i % 20 == 0:
            print(f"Step {i}: Joint position norms = {np.linalg.norm(positions):.3f}")

    print(f"Simulation completed after {simulation_steps} steps")
    print(f"Final joint positions norm: {np.linalg.norm(wbc_controller.current_joint_positions):.3f}")
    print(f"Final joint velocities norm: {np.linalg.norm(wbc_controller.current_joint_velocities):.3f}")

if __name__ == "__main__":
    demonstrate_wbc()
```

## Advantages of Whole Body Control

### 1. Task Integration
WBC naturally integrates multiple tasks that would be difficult to coordinate with traditional control methods. This includes balancing while manipulating objects, walking while avoiding obstacles, or any combination of simultaneous behaviors.

### 2. Constraint Satisfaction
The optimization framework ensures that all physical constraints (joint limits, torque limits, contact constraints) are satisfied simultaneously, preventing the robot from commanding impossible or dangerous motions.

### 3. Graceful Degradation
When conflicts arise between tasks, WBC provides a principled way to handle them through hierarchical optimization, allowing the robot to maintain critical functions (like balance) while sacrificing less important ones.

### 4. Optimal Coordination
WBC finds the optimal coordination between all degrees of freedom to achieve the best possible performance across all tasks, rather than suboptimal sequential task execution.

## Challenges and Limitations

### 1. Computational Complexity
Solving optimization problems in real-time requires significant computational resources, especially for high-DOF systems with many constraints.

### 2. Model Accuracy
WBC relies heavily on accurate models of robot kinematics, dynamics, and environmental interactions. Model errors can lead to poor performance.

### 3. Real-time Requirements
The optimization must be solved faster than the control loop frequency, typically 200-1000 Hz for humanoid robots.

### 4. Tuning Complexity
Setting appropriate weights, priorities, and constraints requires significant expertise and tuning.

## Applications of Whole Body Control

### 1. Humanoid Locomotion
WBC is essential for stable walking, running, and other locomotion patterns in humanoid robots, managing balance, foot placement, and momentum simultaneously.

### 2. Manipulation
Coordinating arm movements while maintaining balance and respecting contact constraints for manipulation tasks.

### 3. Human-Robot Interaction
Managing robot posture and motion during close interaction with humans while maintaining safety.

### 4. Multi-Task Behaviors
Performing complex behaviors that require coordination of multiple body parts simultaneously.

## Summary

Whole Body Control represents a paradigm shift from traditional decoupled control approaches to a unified optimization framework that coordinates all degrees of freedom simultaneously. By formulating robot control as an optimization problem with hierarchical task priorities and constraint satisfaction, WBC enables sophisticated multi-task behaviors that would be extremely difficult to achieve with traditional methods.

The mathematical foundation of WBC, based on optimization theory and hierarchical control, provides a principled approach to handling the complexity of high-DOF robotic systems. While computationally demanding, modern advances in optimization algorithms and computational hardware have made WBC practical for real-time control of humanoid robots.

As humanoid robotics continues to advance, whole body control will remain a critical technology for achieving the complex, coordinated behaviors necessary for robots to operate effectively in human environments.

## Exercises

1. Implement a simple whole body controller for a 6-DOF manipulator that can track a Cartesian trajectory while maintaining a specific joint configuration as a secondary task.

2. Extend the contact model implementation to handle multiple contact points and compute the Zero Moment Point (ZMP) for balance control.

3. Create a hierarchical task structure for a humanoid robot that prioritizes balance, then arm reaching, then posture maintenance.

4. Implement the Jacobian computation for a simple planar manipulator and verify its correctness through numerical differentiation.

5. Design an optimization-based controller that can handle task conflicts by dynamically adjusting task priorities based on the robot's state.