# 3.3 Dynamics and Force Control

## Overview

Robot dynamics is the study of forces and torques that cause motion in robotic systems. Understanding and controlling the dynamic behavior of robots is crucial for achieving precise, stable, and efficient motion, especially in tasks involving interaction with the environment. This chapter covers the fundamental principles of robot dynamics, including the derivation of dynamic equations, force control strategies, and practical implementation of dynamic controllers for humanoid robots.

## Learning Objectives

By the end of this chapter, you will be able to:
- Derive and understand the equations of motion for robotic manipulators
- Implement dynamic models for multi-body robotic systems
- Design force and impedance controllers for robot-environment interaction
- Analyze the stability and performance of dynamic control systems
- Implement hybrid position/force control strategies
- Handle dynamic constraints and contacts in robotic systems

## Robot Dynamics Fundamentals

### Equations of Motion

The dynamics of a robotic manipulator are described by the following equation:

**M(q)q## + C(q,q#)q# + g(q) + J^T(q)F_ext = τ**

Where:
- M(q): Inertia matrix (depends on joint configuration q)
- C(q,q#): Coriolis and centrifugal forces matrix
- g(q): Gravity vector
- J(q): Jacobian matrix
- F_ext: External forces/torques
- τ: Joint torques
- q, q#, q##: Joint positions, velocities, and accelerations

```python
import numpy as np
from scipy.spatial.transform import Rotation as R
import math

class RobotDynamics:
    """
    Class to compute robot dynamics properties
    """

    def __init__(self, robot_model):
        """
        robot_model: Contains kinematic and inertial properties
        """
        self.model = robot_model
        self.n_dof = robot_model.get_num_joints()

    def compute_mass_matrix(self, q):
        """
        Compute the mass matrix M(q) using the Composite Rigid Body Algorithm
        This is a simplified implementation; in practice, more sophisticated methods are used
        """
        # For a simple n-DOF manipulator, we can approximate the mass matrix
        # In reality, this would use the robot's link inertias and kinematic structure
        M = np.zeros((self.n_dof, self.n_dof))

        # This is a placeholder implementation - in practice, use RNEA or CRBA
        for i in range(self.n_dof):
            # Diagonal elements represent link masses
            M[i, i] = self.model.get_link_mass(i) + 0.1  # Add some coupling

        # Add some off-diagonal coupling terms
        for i in range(self.n_dof):
            for j in range(i+1, self.n_dof):
                # Coupling based on geometric relationship
                coupling = 0.1 * np.cos(q[i] - q[j])
                M[i, j] = M[j, i] = coupling

        return M

    def compute_coriolis_matrix(self, q, q_dot):
        """
        Compute the Coriolis and centrifugal forces matrix C(q,q#)
        """
        C = np.zeros((self.n_dof, self.n_dof))

        # Simplified computation - in practice, use more accurate methods
        for i in range(self.n_dof):
            for j in range(self.n_dof):
                # Coriolis terms are typically computed using Christoffel symbols
                # This is a simplified approximation
                if i != j:
                    C[i, j] = 0.5 * np.sin(q[i] - q[j]) * q_dot[j]
                else:
                    C[i, j] = np.cos(q[i]) * q_dot[i]

        return C

    def compute_gravity_vector(self, q, gravity=[0, 0, -9.81]):
        """
        Compute the gravity vector g(q)
        """
        g = np.zeros(self.n_dof)

        # For each joint, compute gravity effect based on orientation
        for i in range(self.n_dof):
            # Simplified gravity effect
            link_mass = self.model.get_link_mass(i)
            g[i] = link_mass * gravity[2] * np.cos(q[i])

        return g

    def compute_coriolis_gravity(self, q, q_dot):
        """
        Compute Coriolis and gravity terms: C(q,q#)q# + g(q)
        """
        C = self.compute_coriolis_matrix(q, q_dot)
        g = self.compute_gravity_vector(q)

        # C(q,q#)q# + g(q)
        return C @ q_dot + g

    def inverse_dynamics(self, q, q_dot, q_ddot):
        """
        Compute required joint torques for desired motion (inverse dynamics)
        """
        M = self.compute_mass_matrix(q)
        Cg = self.compute_coriolis_gravity(q, q_dot)

        # τ = M(q)q## + C(q,q#)q# + g(q)
        tau = M @ q_ddot + Cg

        return tau

    def forward_dynamics(self, q, q_dot, tau):
        """
        Compute joint accelerations from applied torques (forward dynamics)
        """
        M = self.compute_mass_matrix(q)
        Cg = self.compute_coriolis_gravity(q, q_dot)

        # q## = M#(q)[τ - C(q,q#)q# - g(q)]
        M_inv = np.linalg.inv(M)
        q_ddot = M_inv @ (tau - Cg)

        return q_ddot

class SimpleRobotModel:
    """
    Simple robot model for demonstration
    """

    def __init__(self, n_joints=6):
        self.n_joints = n_joints
        # Simple link masses (in kg)
        self.link_masses = [1.0 + 0.5*i for i in range(n_joints)]

    def get_num_joints(self):
        return self.n_joints

    def get_link_mass(self, link_index):
        if link_index < len(self.link_masses):
            return self.link_masses[link_index]
        else:
            return 0.1  # Default small mass
```

### The Recursive Newton-Euler Algorithm (RNEA)

The RNEA is an efficient algorithm for computing inverse dynamics:

```python
class RecursiveNewtonEuler:
    """
    Recursive Newton-Euler Algorithm for inverse dynamics
    """

    def __init__(self, robot_model):
        self.model = robot_model
        self.n_dof = robot_model.get_num_joints()

    def inverse_dynamics_rnea(self, q, q_dot, q_ddot, gravity=np.array([0, 0, -9.81])):
        """
        Compute inverse dynamics using RNEA
        """
        n = self.n_dof

        # Forward pass: compute velocities and accelerations
        v = [np.zeros(3) for _ in range(n)]  # Linear velocities
        w = [np.zeros(3) for _ in range(n)]  # Angular velocities
        v_dot = [np.zeros(3) for _ in range(n)]  # Linear accelerations
        w_dot = [np.zeros(3) for _ in range(n)]  # Angular accelerations

        # Initialize base conditions
        v[0] = np.zeros(3)
        w[0] = np.zeros(3)
        v_dot[0] = gravity
        w_dot[0] = np.zeros(3)

        # Forward recursion
        for i in range(n):
            # For revolute joints (simplified)
            z_axis = np.array([0, 0, 1])  # Joint axis in local frame

            # Transform to world frame (simplified)
            # In practice, this would use the actual transformation matrices
            z_world = z_axis  # Placeholder

            # Compute velocities
            w[i] = w[i-1] if i > 0 else np.zeros(3)  # Simplified
            w[i] += q_dot[i] * z_world

            # Compute accelerations
            w_dot[i] = w_dot[i-1] if i > 0 else np.zeros(3)  # Simplified
            w_dot[i] += q_ddot[i] * z_world + np.cross(w[i], q_dot[i] * z_world)

            # Compute linear velocity and acceleration
            # Simplified - in practice, this would use link transformations
            v[i] = v[i-1] if i > 0 else np.zeros(3)
            v_dot[i] = v_dot[i-1] if i > 0 else np.zeros(3)

        # Backward pass: compute forces and torques
        f = [np.zeros(3) for _ in range(n)]  # Link forces
        n_tau = [np.zeros(3) for _ in range(n)]  # Link torques
        tau = np.zeros(n)  # Joint torques

        for i in range(n-1, -1, -1):
            # Link mass and inertia (simplified)
            m_i = self.model.get_link_mass(i)
            I_i = np.eye(3) * (m_i * 0.1)  # Simplified inertia tensor

            # Compute link forces and torques
            f[i] = m_i * v_dot[i]
            n_tau[i] = I_i @ w_dot[i] + np.cross(w[i], I_i @ w[i])

            # Compute joint torque
            z_axis = np.array([0, 0, 1])  # Joint axis
            tau[i] = np.dot(z_axis, n_tau[i])

        return tau

def example_rnea():
    """
    Example of using RNEA for inverse dynamics
    """
    robot_model = SimpleRobotModel(n_joints=6)
    rnea = RecursiveNewtonEuler(robot_model)

    # Joint states
    q = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])  # Joint positions
    q_dot = np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])  # Joint velocities
    q_ddot = np.array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01])  # Joint accelerations

    # Compute inverse dynamics
    torques = rnea.inverse_dynamics_rnea(q, q_dot, q_ddot)

    print(f"Joint positions: {q}")
    print(f"Joint velocities: {q_dot}")
    print(f"Joint accelerations: {q_ddot}")
    print(f"Required joint torques: {torques}")

    return torques
```

## Force Control Fundamentals

### Impedance Control

Impedance control makes the robot behave like a mechanical system with specified dynamic properties (mass, damping, stiffness):

```python
class ImpedanceController:
    """
    Impedance controller for force control
    """

    def __init__(self, M_d, D_d, K_d, dt=0.005):
        """
        M_d: Desired mass matrix
        D_d: Desired damping matrix
        K_d: Desired stiffness matrix
        dt: Control time step
        """
        self.M_d = M_d
        self.D_d = D_d
 # Desired stiffness matrix
        self.K_d = K_d
        self.dt = dt

        # Check matrix dimensions
        assert M_d.shape == D_d.shape == K_d.shape, "Matrix dimensions must match"

    def compute_impedance_force(self, x_error, x_dot_error, x_ddot_error):
        """
        Compute impedance control force: F = M_d * x_ddot_error + D_d * x_dot_error + K_d * x_error
        """
        F_impedance = self.M_d @ x_ddot_error + self.D_d @ x_dot_error + self.K_d @ x_error
        return F_impedance

    def update(self, desired_state, current_state):
        """
        Update impedance controller
        desired_state: dict with 'position', 'velocity', 'acceleration'
        current_state: dict with 'position', 'velocity', 'acceleration'
        """
        # Compute errors
        x_error = desired_state['position'] - current_state['position']
        x_dot_error = desired_state['velocity'] - current_state['velocity']
        x_ddot_error = desired_state['acceleration'] - current_state['acceleration']

        # Compute impedance force
        F_impedance = self.compute_impedance_force(x_error, x_dot_error, x_ddot_error)

        return F_impedance

class CartesianImpedanceController:
    """
    Cartesian impedance controller for end-effector control
    """

    def __init__(self, robot_model, chain_name, M_cart, D_cart, K_cart, dt=0.005):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.chain = robot_model.chains[chain_name]

        # Cartesian space impedance parameters
        self.M_cart = M_cart  # 6x6 (x, y, z, rx, ry, rz)
        self.D_cart = D_cart
        self.K_cart = K_cart
        self.dt = dt

    def update(self, q, q_dot, desired_pose, current_pose, desired_twist=None, current_twist=None):
        """
        Update Cartesian impedance controller
        q: Current joint positions
        q_dot: Current joint velocities
        desired_pose: [x, y, z, qx, qy, qz, qw] (position + quaternion)
        current_pose: [x, y, z, qx, qy, qz, qw] (position + quaternion)
        """
        # Extract position and orientation errors
        desired_pos = desired_pose[:3]
        current_pos = current_pose[:3]
        pos_error = desired_pos - current_pos

        # Compute orientation error (simplified)
        desired_rot = R.from_quat(desired_pose[3:])  # [qx, qy, qz, qw]
        current_rot = R.from_quat(current_pose[3:])
        rot_error_quat = (desired_rot.inv() * current_rot).as_quat()
        # Convert to axis-angle representation (simplified)
        rot_error = 2 * rot_error_quat[:3] * np.sign(rot_error_quat[3])

        # Combine position and orientation errors
        x_error = np.concatenate([pos_error, rot_error])

        # Compute velocity error
        if desired_twist is not None and current_twist is not None:
            x_dot_error = desired_twist - current_twist
        else:
            # Estimate from position differences (simplified)
            x_dot_error = np.zeros(6)

        # Compute acceleration error (simplified)
        x_ddot_error = np.zeros(6)

        # Compute Cartesian impedance force
        F_cart = self.M_cart @ x_ddot_error + self.D_cart @ x_dot_error + self.K_cart @ x_error

        # Get Jacobian for mapping Cartesian forces to joint torques
        J = self.chain.get_jacobian(q)

        # Map Cartesian forces to joint torques: τ = J^T * F
        tau_impedance = J.T @ F_cart

        return tau_impedance, F_cart

def example_impedance_control():
    """
    Example of impedance control
    """
    # Define desired impedance parameters (6 DOF: x, y, z, rx, ry, rz)
    M_cart = np.eye(6) * 10.0      # Mass matrix
    D_cart = np.eye(6) * 50.0      # Damping matrix
    K_cart = np.eye(6) * 1000.0    # Stiffness matrix

    # Create robot model and controller
    robot_model = SimpleRobotModel(n_joints=6)

    # Add a simple chain for demonstration
    class SimpleChain:
        def get_jacobian(self, q):
            # Simplified Jacobian (6x6 for 6 DOF)
            return np.eye(6)

    robot_model.chains = {'end_effector': SimpleChain()}

    controller = CartesianImpedanceController(
        robot_model, 'end_effector', M_cart, D_cart, K_cart
    )

    # Current and desired states
    current_pose = np.array([0.5, 0.3, 0.8, 0, 0, 0, 1])  # [pos, quat]
    desired_pose = np.array([0.6, 0.4, 0.8, 0, 0, 0, 1])  # [pos, quat]

    current_joints = np.zeros(6)
    current_joints_vel = np.zeros(6)

    # Compute impedance control torques
    tau_impedance, F_cart = controller.update(
        current_joints, current_joints_vel, desired_pose, current_pose
    )

    print(f"Cartesian impedance force: {F_cart}")
    print(f"Joint torques: {tau_impedance}")

    return tau_impedance
```

### Admittance Control

Admittance control is the dual of impedance control, where motion is generated in response to applied forces:

```python
class AdmittanceController:
    """
    Admittance controller - motion is generated in response to forces
    """

    def __init__(self, M_a, D_a, K_a, dt=0.005):
        """
        M_a: Admittance mass matrix
        D_a: Admittance damping matrix
        K_a: Admittance stiffness matrix
        dt: Control time step
        """
        self.M_a = M_a
        self.D_a = D_a
        self.K_a = K_a
        self.dt = dt

        # State variables for integration
        self.x = np.zeros(M_a.shape[0])  # Position
        self.x_dot = np.zeros(M_a.shape[0])  # Velocity

    def update(self, applied_force, desired_pose=None):
        """
        Update admittance controller
        applied_force: External force applied to the system
        desired_pose: Optional desired pose for reference
        """
        # Compute acceleration: M_a * x_ddot + D_a * x_dot + K_a * x = F
        # x_ddot = M_a# * (F - D_a * x_dot - K_a * x)

        if desired_pose is not None:
            # Add stiffness to desired pose
            pos_error = desired_pose - self.x
            force_feedback = self.K_a @ pos_error
            applied_force = applied_force + force_feedback

        # Compute acceleration
        M_inv = np.linalg.inv(self.M_a)
        x_ddot = M_inv @ (applied_force - self.D_a @ self.x_dot - self.K_a @ self.x)

        # Integrate to get new velocity and position
        self.x_dot = self.x_dot + x_ddot * self.dt
        self.x = self.x + self.x_dot * self.dt

        return self.x, self.x_dot, x_ddot

class HybridPositionForceController:
    """
    Hybrid position/force controller that can control different DOFs independently
    """

    def __init__(self, robot_model, chain_name, dt=0.005):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.dt = dt

        # Selection matrix (identity for full 6D control)
        self.Sigma = np.eye(6)  # Controls which DOFs are position-controlled vs force-controlled

        # Position controller gains
        self.Kp_pos = np.diag([1000, 1000, 1000, 100, 100, 100])  # Higher for translation
        self.Kd_pos = np.diag([100, 100, 100, 50, 50, 50])

        # Force controller gains
        self.Kp_force = np.diag([10, 10, 10, 5, 5, 5])
        self.Kd_force = np.diag([1, 1, 1, 0.5, 0.5, 0.5])

    def update(self, q, q_dot, desired_pose, current_pose, desired_force, current_force,
               force_frame='world'):
        """
        Update hybrid controller
        desired_pose: Desired Cartesian pose [x, y, z, qx, qy, qz, qw]
        current_pose: Current Cartesian pose
        desired_force: Desired force/torque in selected DOFs
        current_force: Measured force/torque
        """
        # Compute pose error
        pos_error = desired_pose[:3] - current_pose[:3]

        # Compute orientation error (simplified)
        desired_rot = R.from_quat(desired_pose[3:])
        current_rot = R.from_quat(current_pose[3:])
        rot_error_quat = (desired_rot.inv() * current_rot).as_quat()
        rot_error = 2 * rot_error_quat[:3] * np.sign(rot_error_quat[3])

        pose_error = np.concatenate([pos_error, rot_error])

        # Compute force error
        force_error = desired_force - current_force

        # Get Jacobian
        chain = self.robot_model.chains[self.chain_name]
        J = chain.get_jacobian(q)

        # Compute selection matrix for active constraints
        # This would typically be computed based on contact constraints
        S = self.Sigma  # For now, use the full selection matrix

        # Compute position control component
        x_ddot_pos = -self.Kp_pos @ pose_error - self.Kd_pos @ np.zeros(6)  # Assuming zero velocity error for simplicity

        # Compute force control component
        F_error_integrated = force_error  # In practice, integrate force error
        x_ddot_force = self.Kp_force @ F_error_integrated + self.Kd_force @ np.zeros(6)

        # Combine position and force control
        # This is a simplified combination - in practice, more sophisticated methods are used
        x_ddot_cmd = S @ x_ddot_pos + (np.eye(6) - S) @ x_ddot_force

        # Map Cartesian acceleration to joint torques using inverse dynamics
        # This requires more complex treatment in practice
        tau_cmd = J.T @ (np.eye(6) @ x_ddot_cmd)  # Simplified

        return tau_cmd, x_ddot_cmd

def example_hybrid_control():
    """
    Example of hybrid position/force control
    """
    # Create robot model
    robot_model = SimpleRobotModel(n_joints=6)

    # Add a simple chain for demonstration
    class SimpleChain:
        def get_jacobian(self, q):
            return np.eye(6)

    robot_model.chains = {'end_effector': SimpleChain()}

    controller = HybridPositionForceController(robot_model, 'end_effector')

    # Current and desired states
    current_pose = np.array([0.5, 0.3, 0.8, 0, 0, 0, 1])
    desired_pose = np.array([0.6, 0.4, 0.8, 0, 0, 0, 1])

    current_force = np.array([5.0, 2.0, 0.0, 0.1, 0.05, 0.0])
    desired_force = np.array([10.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # Force control in x direction

    current_joints = np.zeros(6)
    current_joints_vel = np.zeros(6)

    # Compute hybrid control torques
    tau_cmd, x_ddot_cmd = controller.update(
        current_joints, current_joints_vel,
        desired_pose, current_pose,
        desired_force, current_force
    )

    print(f"Hybrid control torques: {tau_cmd}")
    print(f"Cartesian acceleration command: {x_ddot_cmd}")

    return tau_cmd
```

## Advanced Dynamic Control Techniques

### Operational Space Control

Operational space control allows direct control of task-space variables while maintaining dynamic consistency:

```python
class OperationalSpaceController:
    """
    Operational Space Controller (OSC)
    """

    def __init__(self, robot_model, chain_name, dt=0.005):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.dt = dt

        # Task space controller gains
        self.Kp_task = np.diag([1000, 1000, 1000, 100, 100, 100])  # Position gains
        self.Kd_task = np.diag([100, 100, 100, 50, 50, 50])        # Velocity gains

        # Null space controller gains (for secondary tasks)
        self.Kp_null = np.diag([10, 10, 10, 10, 10, 10])

    def compute_operational_space_control(self, q, q_dot, desired_x, current_x,
                                        desired_x_dot=None, current_x_dot=None,
                                        secondary_task=None):
        """
        Compute operational space control
        """
        chain = self.robot_model.chains[self.chain_name]
        J = chain.get_jacobian(q)

        # Compute task space error
        x_error = desired_x - current_x

        if desired_x_dot is not None and current_x_dot is not None:
            x_dot_error = desired_x_dot - current_x_dot
        else:
            # Estimate from position error
            x_dot_error = x_error / self.dt  # Simplified

        # Compute task space acceleration command
        x_ddot_cmd = -self.Kp_task @ x_error - self.Kd_task @ x_dot_error

        # Compute operational space inertia
        M = self.robot_model.compute_mass_matrix(q)
        M_inv = np.linalg.inv(M)

        # Lambda = (J * M# * J^T)# (task space inertia)
        JMJt = J @ M_inv @ J.T
        Lambda = np.linalg.inv(JMJt)

        # Compute operational space forces
        F_task = Lambda @ x_ddot_cmd

        # Compute joint torques for primary task
        tau_task = J.T @ F_task

        # Compute null space torques for secondary tasks
        tau_null = np.zeros(len(q))

        if secondary_task is not None:
            # Compute null space projection: N = I - M# * J^T * Lambda * J
            N = np.eye(len(q)) - M_inv @ J.T @ Lambda @ J

            # Apply secondary task in null space
            tau_null_task = self.Kp_null @ (secondary_task - q)  # Simple joint centering
            tau_null = N @ tau_null_task

        # Add gravity compensation
        g = self.robot_model.compute_gravity_vector(q)
        tau_gravity = g

        # Total torque
        tau_total = tau_task + tau_null + tau_gravity

        return tau_total, F_task

    def compute_jacobian_derivative(self, q, q_dot):
        """
        Compute Jacobian derivative J#
        This is needed for more accurate operational space control
        """
        # Simplified computation - in practice, this involves more complex derivatives
        J_dot = np.zeros_like(self.robot_model.chains[self.chain_name].get_jacobian(q))
        return J_dot

def example_operational_space_control():
    """
    Example of operational space control
    """
    # Create robot model
    robot_model = SimpleRobotModel(n_joints=6)

    # Add a simple chain for demonstration
    class SimpleChain:
        def get_jacobian(self, q):
            return np.eye(6)

        def compute_mass_matrix(self, q):
            return np.eye(6) * 2.0  # Simplified mass matrix

        def compute_gravity_vector(self, q):
            return np.zeros(6)  # Simplified gravity

    robot_model.chains = {'end_effector': SimpleChain()}
    robot_model.compute_mass_matrix = lambda q: np.eye(6) * 2.0
    robot_model.compute_gravity_vector = lambda q: np.zeros(6)

    controller = OperationalSpaceController(robot_model, 'end_effector')

    # Task space variables
    current_x = np.array([0.5, 0.3, 0.8, 0.0, 0.0, 0.0])  # [pos, rot]
    desired_x = np.array([0.6, 0.4, 0.8, 0.0, 0.0, 0.0])

    current_q = np.zeros(6)
    current_q_dot = np.zeros(6)

    # Compute operational space control
    tau_total, F_task = controller.compute_operational_space_control(
        current_q, current_q_dot, desired_x, current_x
    )

    print(f"Operational space control torques: {tau_total}")
    print(f"Task space forces: {F_task}")

    return tau_total
```

### Adaptive Control for Unknown Dynamics

Adaptive control techniques can handle uncertainties in robot dynamics:

```python
class AdaptiveController:
    """
    Adaptive controller for unknown robot dynamics
    """

    def __init__(self, n_dof, dt=0.005):
        self.n_dof = n_dof
        self.dt = dt

        # Adaptive parameters
        self.theta_hat = np.zeros(n_dof)  # Estimated parameters
        self.P = np.eye(n_dof) * 1000    # Parameter covariance matrix
        self.gamma = 1.0                 # Learning rate

        # Control gains
        self.Kp = np.eye(n_dof) * 100
        self.Kd = np.eye(n_dof) * 20

    def regressor_matrix(self, q, q_dot, q_ddot_desired):
        """
        Compute regressor matrix Y such that tau = Y * theta
        This is a simplified example - in practice, this would be more complex
        """
        # For a simple 1-DOF system: tau = m*q## + c*q# + g
        # Y = [q##, q#, 1], theta = [m, c, g]
        # For n-DOF, this becomes more complex

        # Simplified regressor (this is just an example structure)
        Y = np.zeros((self.n_dof, self.n_dof))
        for i in range(self.n_dof):
            Y[i, i] = q_ddot_desired[i]  # Acceleration terms
            Y[i, (i+1) % self.n_dof] = q_dot[i]  # Velocity terms
            Y[i, min(i+2, self.n_dof-1)] = 1.0   # Gravity terms (simplified)

        return Y

    def update(self, q, q_dot, q_desired, q_dot_desired, q_ddot_desired):
        """
        Update adaptive controller
        """
        # Compute tracking error
        q_error = q_desired - q
        q_dot_error = q_dot_desired - q_dot

        # Compute control signal
        s = q_dot_error + self.Kp @ q_error  # Sliding surface

        # Regressor matrix
        Y = self.regressor_matrix(q, q_dot, q_ddot_desired)

        # Adaptive control law
        tau_cmd = Y @ self.theta_hat - self.Kd @ s

        # Parameter update law
        # theta#_hat = gamma * P * Y^T * s
        dtheta = self.gamma * self.P @ Y.T @ s * self.dt
        self.theta_hat = self.theta_hat + dtheta

        # Update parameter covariance
        # P# = gamma * (Y^T * s * s^T * Y - P)
        P_dot = self.gamma * (Y.T @ s @ s.T @ Y - self.P)
        self.P = self.P + P_dot * self.dt

        return tau_cmd, self.theta_hat

class RobustController:
    """
    Robust controller to handle modeling uncertainties and disturbances
    """

    def __init__(self, n_dof, dt=0.005):
        self.n_dof = n_dof
        self.dt = dt

        # Control gains
        self.Kp = np.eye(n_dof) * 100
        self.Kd = np.eye(n_dof) * 20

        # Robustness parameters
        self.k_robust = 5.0  # Robust control gain
        self.delta = 0.1     # Boundary layer thickness

    def update(self, q, q_dot, q_desired, q_dot_desired, q_ddot_desired, disturbance_estimate=0):
        """
        Update robust controller
        """
        # Compute tracking error
        q_error = q_desired - q
        q_dot_error = q_dot_desired - q_dot

        # Compute desired acceleration
        q_ddot_cmd = q_ddot_desired + self.Kp @ q_error + self.Kd @ q_dot_error

        # Robust control term to handle uncertainties
        s = q_dot_error + self.Kp @ q_error  # Sliding surface

        # Boundary layer saturation function
        robust_term = np.zeros(self.n_dof)
        for i in range(self.n_dof):
            if abs(s[i]) <= self.delta:
                robust_term[i] = s[i] / self.delta
            else:
                robust_term[i] = np.sign(s[i])

        tau_robust = -self.k_robust * robust_term - disturbance_estimate

        # Total control
        tau_cmd = tau_robust

        return tau_cmd
```

## Force/Torque Sensing and Control

### Sensor Integration

Proper integration of force/torque sensors is crucial for force control:

```python
class ForceTorqueSensor:
    """
    Force/Torque sensor interface and processing
    """

    def __init__(self, sensor_noise_std=0.1, bias_drift_rate=1e-5):
        self.bias = np.zeros(6)  # 3 forces + 3 torques
        self.bias_drift_rate = bias_drift_rate
        self.noise_std = sensor_noise_std
        self.raw_reading = np.zeros(6)

    def read_sensor(self):
        """
        Simulate sensor reading with noise and bias
        """
        # Add noise
        noise = np.random.normal(0, self.noise_std, 6)

        # Simulate bias drift
        self.bias += np.random.normal(0, self.bias_drift_rate, 6)

        # Return biased and noisy reading
        return self.raw_reading + self.bias + noise

    def bias_calibration(self, num_samples=100):
        """
        Calibrate sensor bias (assuming no external forces)
        """
        samples = []
        for _ in range(num_samples):
            samples.append(self.read_sensor())

        # Average to estimate bias
        measured_bias = np.mean(samples, axis=0)
        self.bias = measured_bias
        return self.bias

    def filter_reading(self, raw_reading, filter_coeff=0.1):
        """
        Apply low-pass filter to sensor reading
        """
        if not hasattr(self, 'filtered_reading'):
            self.filtered_reading = raw_reading
        else:
            self.filtered_reading = (1 - filter_coeff) * self.filtered_reading + filter_coeff * raw_reading

        return self.filtered_reading

class CartesianForceController:
    """
    Cartesian force controller with sensor integration
    """

    def __init__(self, robot_model, chain_name, dt=0.005):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.dt = dt

        # Force control gains
        self.Kp_force = np.diag([100, 100, 100, 50, 50, 50])
        self.Ki_force = np.diag([10, 10, 10, 5, 5, 5])
        self.Kd_force = np.diag([20, 20, 20, 10, 10, 10])

        # Force error integrator
        self.force_error_integral = np.zeros(6)
        self.max_integral = 100  # Anti-windup

        # Sensor
        self.ft_sensor = ForceTorqueSensor()

    def update(self, q, q_dot, desired_wrench, current_wrench, contact_frame='world'):
        """
        Update Cartesian force controller
        desired_wrench: [Fx, Fy, Fz, Tx, Ty, Tz]
        current_wrench: Measured wrench from sensor
        """
        # Compute force error
        force_error = desired_wrench - current_wrench

        # Integrate error (with anti-windup)
        self.force_error_integral = self.force_error_integral + force_error * self.dt
        self.force_error_integral = np.clip(self.force_error_integral, -self.max_integral, self.max_integral)

        # Compute Cartesian force command
        F_cmd = (self.Kp_force @ force_error +
                self.Ki_force @ self.force_error_integral +
                self.Kd_force @ np.zeros(6))  # Simplified - would need force derivative

        # Get Jacobian transpose to map forces to joint torques
        chain = self.robot_model.chains[self.chain_name]
        J = chain.get_jacobian(q)

        # Map Cartesian forces to joint torques: τ = J^T * F
        tau_cmd = J.T @ F_cmd

        return tau_cmd, F_cmd

def example_force_control():
    """
    Example of force control with sensor integration
    """
    # Create robot model
    robot_model = SimpleRobotModel(n_joints=6)

    # Add a simple chain for demonstration
    class SimpleChain:
        def get_jacobian(self, q):
            return np.eye(6)

    robot_model.chains = {'end_effector': SimpleChain()}

    controller = CartesianForceController(robot_model, 'end_effector')

    # Desired and current wrenches
    desired_wrench = np.array([10.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # 10N in x direction
    current_wrench = np.array([5.0, 1.0, 0.1, 0.05, 0.02, 0.01])  # Measured forces

    current_q = np.zeros(6)
    current_q_dot = np.zeros(6)

    # Compute force control
    tau_cmd, F_cmd = controller.update(
        current_q, current_q_dot, desired_wrench, current_wrench
    )

    print(f"Force control torques: {tau_cmd}")
    print(f"Cartesian force command: {F_cmd}")

    return tau_cmd
```

## Practical Implementation Considerations

### Control Architecture

A practical dynamic control system requires careful architecture design:

```python
class DynamicControlSystem:
    """
    Complete dynamic control system architecture
    """

    def __init__(self, robot_model, control_frequency=200):
        self.robot_model = robot_model
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency

        # Controllers
        self.impedance_controller = None
        self.force_controller = None
        self.position_controller = None

        # State variables
        self.current_q = np.zeros(robot_model.get_num_joints())
        self.current_q_dot = np.zeros(robot_model.get_num_joints())
        self.current_q_ddot = np.zeros(robot_model.get_num_joints())

        # External force estimator
        self.external_force_estimator = ExternalForceEstimator(robot_model)

        # Safety limits
        self.max_torque = 100.0  # Nm
        self.max_velocity = 2.0  # rad/s

    def set_impedance_controller(self, M_d, D_d, K_d):
        """Set up impedance controller"""
        self.impedance_controller = ImpedanceController(M_d, D_d, K_d, self.dt)

    def set_force_controller(self, Kp, Ki, Kd):
        """Set up force controller"""
        self.force_controller = {
            'Kp': Kp,
            'Ki': Ki,
            'Kd': Kd,
            'error_integral': np.zeros(6),
            'error_derivative': np.zeros(6)
        }

    def update(self, desired_state, sensor_data):
        """
        Main control update function
        desired_state: dict with desired positions, velocities, forces, etc.
        sensor_data: dict with joint positions, velocities, forces, etc.
        """
        # Update internal state
        self.current_q = sensor_data.get('joint_positions', self.current_q)
        self.current_q_dot = sensor_data.get('joint_velocities', self.current_q_dot)

        # Estimate external forces
        external_forces = self.external_force_estimator.estimate(
            self.current_q, self.current_q_dot, sensor_data.get('applied_torques', np.zeros(len(self.current_q)))
        )

        # Initialize total torque
        tau_total = np.zeros(len(self.current_q))

        # Apply different control modes based on task
        control_mode = desired_state.get('control_mode', 'position')

        if control_mode == 'position':
            tau_total += self._compute_position_control(desired_state)
        elif control_mode == 'impedance':
            tau_total += self._compute_impedance_control(desired_state)
        elif control_mode == 'force':
            tau_total += self._compute_force_control(desired_state, external_forces)
        elif control_mode == 'hybrid':
            tau_total += self._compute_hybrid_control(desired_state, external_forces)

        # Add gravity compensation
        dynamics = RobotDynamics(self.robot_model)
        g = dynamics.compute_gravity_vector(self.current_q)
        tau_total += g

        # Apply safety limits
        tau_total = np.clip(tau_total, -self.max_torque, self.max_torque)

        # Check velocity limits
        if np.any(np.abs(self.current_q_dot) > self.max_velocity):
            # Reduce control effort if velocity limits exceeded
            tau_total *= 0.5

        return tau_total

    def _compute_position_control(self, desired_state):
        """Compute position control torques"""
        # PD control: τ = Kp * (qd - q) + Kd * (q#d - q#)
        q_desired = desired_state.get('q_desired', self.current_q)
        q_dot_desired = desired_state.get('q_dot_desired', np.zeros_like(self.current_q))

        Kp = desired_state.get('Kp_pos', np.eye(len(self.current_q)) * 100)
        Kd = desired_state.get('Kd_pos', np.eye(len(self.current_q)) * 20)

        pos_error = q_desired - self.current_q
        vel_error = q_dot_desired - self.current_q_dot

        tau_pos = Kp @ pos_error + Kd @ vel_error
        return tau_pos

    def _compute_impedance_control(self, desired_state):
        """Compute impedance control torques"""
        if self.impedance_controller is None:
            return np.zeros(len(self.current_q))

        # This would involve more complex computation involving task space
        # For now, return zeros
        return np.zeros(len(self.current_q))

    def _compute_force_control(self, desired_state, external_forces):
        """Compute force control torques"""
        if 'force_controller' not in self.__dict__:
            return np.zeros(len(self.current_q))

        # This would involve Cartesian force control
        # For now, return zeros
        return np.zeros(len(self.current_q))

    def _compute_hybrid_control(self, desired_state, external_forces):
        """Compute hybrid position/force control torques"""
        # This would combine position and force control
        # For now, return zeros
        return np.zeros(len(self.current_q))

class ExternalForceEstimator:
    """
    Estimate external forces using robot dynamics
    """

    def __init__(self, robot_model, filter_coeff=0.9):
        self.robot_model = robot_model
        self.filter_coeff = filter_coeff
        self.dynamics = RobotDynamics(robot_model)
        self.estimated_force = np.zeros(robot_model.get_num_joints())

    def estimate(self, q, q_dot, applied_tau, q_ddot=None):
        """
        Estimate external forces using inverse dynamics residual
        """
        if q_ddot is None:
            # If acceleration not available, estimate it
            # This is a simplified approach
            q_ddot = np.zeros_like(q)

        # Compute expected torques from dynamics
        expected_tau = self.dynamics.inverse_dynamics(q, q_dot, q_ddot)

        # External torque is the difference
        external_tau = applied_tau - expected_tau

        # Apply filtering to reduce noise
        self.estimated_force = (self.filter_coeff * self.estimated_force +
                               (1 - self.filter_coeff) * external_tau)

        return self.estimated_force

def example_dynamic_control_system():
    """
    Example of complete dynamic control system
    """
    print("=== Dynamic Control System Example ===")

    # Create robot model
    robot_model = SimpleRobotModel(n_joints=6)

    # Initialize control system
    control_system = DynamicControlSystem(robot_model, control_frequency=200)

    # Set up controllers
    M_d = np.eye(6) * 1.0
    D_d = np.eye(6) * 10.0
    K_d = np.eye(6) * 100.0
    control_system.set_impedance_controller(M_d, D_d, K_d)

    # Simulation
    for step in range(100):
        # Simulate sensor data
        sensor_data = {
            'joint_positions': np.random.normal(0, 0.1, 6),
            'joint_velocities': np.random.normal(0, 0.1, 6),
            'applied_torques': np.random.normal(0, 10, 6)
        }

        # Simulate desired state
        desired_state = {
            'control_mode': 'position',
            'q_desired': np.zeros(6),
            'q_dot_desired': np.zeros(6),
            'Kp_pos': np.eye(6) * 100,
            'Kd_pos': np.eye(6) * 20
        }

        # Update control system
        torques = control_system.update(desired_state, sensor_data)

        # Print progress every 20 steps
        if step % 20 == 0:
            print(f"Step {step}: Max torque = {np.max(np.abs(torques)):.3f}")

    print("Dynamic control system example completed.")
    return torques

if __name__ == "__main__":
    # Run examples
    print("Running Dynamics and Force Control Examples...")

    torques_rnea = example_rnea()
    impedance_torques = example_impedance_control()
    hybrid_torques = example_hybrid_control()
    osc_torques = example_operational_space_control()
    force_torques = example_force_control()
    final_torques = example_dynamic_control_system()

    print("\n=== Summary ===")
    print(f"RNEA example completed")
    print(f"Impedance control torques: {impedance_torques}")
    print(f"Hybrid control torques: {hybrid_torques}")
    print(f"Operational space control torques: {osc_torques}")
    print(f"Force control torques: {force_torques}")
    print(f"Dynamic control system example completed")