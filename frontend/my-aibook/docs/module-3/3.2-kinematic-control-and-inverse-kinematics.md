# 3.2 Kinematic Control and Inverse Kinematics

## Overview

Kinematic control forms the foundation of robot motion, enabling precise positioning and orientation of end-effectors and other points of interest on a robotic system. Inverse Kinematics (IK) is a critical component of kinematic control that determines the joint angles required to achieve desired end-effector poses. This chapter explores the mathematical foundations, algorithms, and practical implementations of kinematic control and inverse kinematics for humanoid robots and other multi-degree-of-freedom systems.

## Learning Objectives

By the end of this chapter, you will be able to:
- Understand the mathematical foundations of forward and inverse kinematics
- Implement various inverse kinematics algorithms for robotic manipulators
- Analyze the properties of different kinematic chains and their Jacobians
- Handle kinematic singularities and joint limit constraints
- Implement multi-task kinematic control for redundant manipulators
- Design kinematic controllers for complex humanoid robot tasks

## Forward Kinematics

Forward kinematics is the process of computing the position and orientation of a robot's end-effector given the joint angles. For a robotic manipulator with n joints, forward kinematics maps joint space coordinates to task space coordinates.

### Homogeneous Transformation Matrices

The pose (position and orientation) of each link in a kinematic chain can be represented using homogeneous transformation matrices. A 4x4 homogeneous transformation matrix has the form:

```
T = [R  p]
    [0  1]
```

Where R is a 3x3 rotation matrix and p is a 3x1 position vector.

```python
import numpy as np
from scipy.spatial.transform import Rotation as R
import math

def dh_transform(a, alpha, d, theta):
    """
    Denavit-Hartenberg transformation matrix
    a: link length
    alpha: link twist
    d: link offset
    theta: joint angle
    """
    T = np.array([
        [np.cos(theta), -np.sin(theta)*np.cos(alpha), np.sin(theta)*np.sin(alpha), a*np.cos(theta)],
        [np.sin(theta), np.cos(theta)*np.cos(alpha), -np.cos(theta)*np.sin(alpha), a*np.sin(theta)],
        [0, np.sin(alpha), np.cos(alpha), d],
        [0, 0, 0, 1]
    ])
    return T

def forward_kinematics(joint_angles, dh_params):
    """
    Compute forward kinematics using Denavit-Hartenberg parameters
    joint_angles: array of joint angles
    dh_params: list of tuples (a, alpha, d, theta_offset)
    """
    T_total = np.eye(4)  # Start with identity matrix

    for i, (a, alpha, d, theta_offset) in enumerate(dh_params):
        theta = joint_angles[i] + theta_offset
        T_link = dh_transform(a, alpha, d, theta)
        T_total = T_total @ T_link

    return T_total

def extract_position_orientation(T):
    """
    Extract position and orientation from homogeneous transformation
    """
    position = T[:3, 3]
    orientation_matrix = T[:3, :3]
    orientation_quat = R.from_matrix(orientation_matrix).as_quat()

    return position, orientation_quat
```

### Kinematic Trees and Chain Traversal

For complex robots like humanoid systems, multiple kinematic chains exist (arms, legs, spine). Efficient traversal algorithms are needed to compute forward kinematics for all parts of the robot.

```python
class KinematicChain:
    """Represents a kinematic chain for a robot"""

    def __init__(self, chain_name, joint_names, dh_parameters):
        self.name = chain_name
        self.joint_names = joint_names
        self.dh_params = dh_parameters  # List of (a, alpha, d, theta_offset) tuples
        self.transforms = []  # Computed transforms for each joint

    def compute_forward_kinematics(self, joint_angles):
        """Compute forward kinematics for the entire chain"""
        if len(joint_angles) != len(self.dh_params):
            raise ValueError("Joint angles length must match DH parameters length")

        transforms = [np.eye(4)]  # Base transform

        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):
            theta = joint_angles[i] + theta_offset
            T_link = dh_transform(a, alpha, d, theta)
            T_cumulative = transforms[-1] @ T_link
            transforms.append(T_cumulative)

        self.transforms = transforms[1:]  # Exclude base transform
        return self.transforms[-1]  # Return end-effector transform

    def get_link_transform(self, link_index):
        """Get transform for a specific link in the chain"""
        if link_index < 0 or link_index >= len(self.transforms):
            raise IndexError("Link index out of range")
        return self.transforms[link_index]

    def get_end_effector_pose(self):
        """Get the end-effector pose"""
        if not self.transforms:
            raise ValueError("Forward kinematics not computed yet")
        return extract_position_orientation(self.transforms[-1])

class RobotModel:
    """Complete robot model with multiple kinematic chains"""

    def __init__(self):
        self.chains = {}
        self.joint_limits = {}
        self.all_joint_names = []

    def add_chain(self, name, joint_names, dh_params):
        """Add a kinematic chain to the robot"""
        chain = KinematicChain(name, joint_names, dh_params)
        self.chains[name] = chain
        self.all_joint_names.extend(joint_names)

    def set_joint_limits(self, joint_name, lower_limit, upper_limit):
        """Set joint limits"""
        self.joint_limits[joint_name] = (lower_limit, upper_limit)

    def compute_all_kinematics(self, joint_angles_dict):
        """Compute forward kinematics for all chains"""
        results = {}

        for chain_name, chain in self.chains.items():
            # Extract joint angles for this chain
            chain_angles = np.array([joint_angles_dict[name] for name in chain.joint_names])
            end_effector_transform = chain.compute_forward_kinematics(chain_angles)
            results[chain_name] = end_effector_transform

        return results

    def get_jacobian(self, chain_name, joint_angles, link_index=-1):
        """Compute geometric Jacobian for a chain"""
        chain = self.chains[chain_name]
        n_joints = len(joint_angles)

        # Compute all transforms first
        chain.compute_forward_kinematics(joint_angles)

        # Get end-effector transform if link_index is -1 (default)
        if link_index == -1:
            link_transform = chain.transforms[-1]
        else:
            link_transform = chain.transforms[link_index]

        ee_pos = link_transform[:3, 3]

        # Initialize Jacobian
        J = np.zeros((6, n_joints))  # 6D (linear + angular)

        for i in range(n_joints):
            # Get the transform of the i-th joint
            if i == 0:
                joint_pos = np.zeros(3)
                joint_axis = np.array([0, 0, 1])  # Assuming z-axis rotation
            else:
                joint_transform = chain.transforms[i-1]
                joint_pos = joint_transform[:3, 3]
                # For revolute joints, axis is z-axis in joint frame
                joint_axis = joint_transform[:3, 2]  # z-axis of joint frame

            # Linear velocity component: Jv = z Ã— (pe - pi)
            J[:3, i] = np.cross(joint_axis, ee_pos - joint_pos)
            # Angular velocity component: Jw = z
            J[3:, i] = joint_axis

        return J
```

## Inverse Kinematics Algorithms

### Analytical Inverse Kinematics

For simple robots with specific geometries, analytical solutions to inverse kinematics can be derived. These solutions are computationally efficient and provide all possible solutions.

```python
def inverse_kinematics_2dof_2r(l1, l2, x, y):
    """
    Analytical inverse kinematics for 2-DOF planar manipulator
    l1, l2: link lengths
    x, y: desired end-effector position
    """
    # Check if position is reachable
    distance = np.sqrt(x**2 + y**2)
    if distance > l1 + l2:
        raise ValueError("Position is out of reach")
    if distance < abs(l1 - l2):
        raise ValueError("Position is inside workspace")

    # Compute elbow-up solution
    cos_theta2 = (x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2)
    sin_theta2 = np.sqrt(1 - cos_theta2**2)  # Take positive square root for elbow-up

    theta2 = np.arctan2(sin_theta2, cos_theta2)

    k1 = l1 + l2 * cos_theta2
    k2 = l2 * sin_theta2

    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)

    return np.array([theta1, theta2])

def inverse_kinematics_3dof_spherical_wrist(l1, l2, l3, pos, orientation):
    """
    Analytical IK for 6-DOF manipulator with spherical wrist
    This is a simplified example for educational purposes
    """
    # Position inverse kinematics (first 3 joints)
    x, y, z = pos

    # Wrist center position
    wrist_center_x = x - l3 * orientation[0, 2]  # orientation[2] is the approach vector
    wrist_center_y = y - l3 * orientation[1, 2]
    wrist_center_z = z - l3 * orientation[2, 2]

    # Compute first 3 joint angles
    theta1 = np.arctan2(wrist_center_y, wrist_center_x)

    r = np.sqrt(wrist_center_x**2 + wrist_center_y**2)
    s = wrist_center_z - l1  # l1 is shoulder height

    D = (r**2 + s**2 - l2**2 - l3**2) / (2 * l2 * l3)
    theta3 = np.arctan2(np.sqrt(1 - D**2), D)  # Elbow up solution

    theta2 = np.arctan2(s, r) - np.arctan2(l3 * np.sin(theta3), l2 + l3 * np.cos(theta3))

    # Orientation inverse kinematics (last 3 joints) would follow
    # This is simplified and would require the full spherical wrist solution

    return np.array([theta1, theta2, theta3, 0, 0, 0])  # Placeholder for last 3 joints
```

### Numerical Inverse Kinematics

For complex robots without analytical solutions, numerical methods are used to solve inverse kinematics iteratively.

```python
def jacobian_inverse_kinematics(chain, target_pose, initial_joints,
                              max_iterations=100, tolerance=1e-6, alpha=0.1):
    """
    Jacobian-based inverse kinematics
    """
    joints = initial_joints.copy()

    for i in range(max_iterations):
        # Compute forward kinematics
        current_transform = chain.compute_forward_kinematics(joints)
        current_pos, current_quat = extract_position_orientation(current_transform)

        # Compute pose error
        pos_error = target_pose[:3] - current_pos

        # For orientation error, we'll use a simplified approach
        # In practice, you'd want to compute proper rotation error
        current_rot = R.from_quat(current_quat)
        target_rot = R.from_quat(target_pose[3:])  # Assuming target is [pos, quat]
        rot_error = (target_rot.inv() * current_rot).as_rotvec()

        # Combine position and rotation errors
        error = np.concatenate([pos_error, rot_error])

        # Check if error is within tolerance
        if np.linalg.norm(error) < tolerance:
            break

        # Compute Jacobian
        J = chain.get_jacobian(joints)

        # Compute joint velocity
        # Use damped least squares to handle singularities
        damping = 0.01
        JJT = J @ J.T
        damping_matrix = damping**2 * np.eye(JJT.shape[0])
        J_pseudo = J.T @ np.linalg.inv(JJT + damping_matrix)

        joint_velocity = J_pseudo @ error

        # Update joints
        joints = joints + alpha * joint_velocity

    return joints, np.linalg.norm(error) < tolerance

def jacobian_transpose_ik(chain, target_pose, initial_joints,
                         max_iterations=100, tolerance=1e-6, alpha=0.1):
    """
    Jacobian transpose method for inverse kinematics
    """
    joints = initial_joints.copy()

    for i in range(max_iterations):
        # Compute forward kinematics
        current_transform = chain.compute_forward_kinematics(joints)
        current_pos, current_quat = extract_position_orientation(current_transform)

        # Compute pose error
        pos_error = target_pose[:3] - current_pos
        current_rot = R.from_quat(current_quat)
        target_rot = R.from_quat(target_pose[3:])
        rot_error = (target_rot.inv() * current_rot).as_rotvec()

        error = np.concatenate([pos_error, rot_error])

        if np.linalg.norm(error) < tolerance:
            break

        # Compute Jacobian
        J = chain.get_jacobian(joints)

        # Use transpose of Jacobian
        joint_velocity = alpha * J.T @ error
        joints = joints + joint_velocity

    return joints, np.linalg.norm(error) < tolerance
```

### Optimization-Based Inverse Kinematics

For complex multi-task scenarios, inverse kinematics can be formulated as an optimization problem:

```python
from scipy.optimize import minimize

class OptimizationBasedIK:
    """
    Inverse kinematics formulated as an optimization problem
    """

    def __init__(self, robot_model, chain_name):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.chain = robot_model.chains[chain_name]

        # Default weights for different terms
        self.position_weight = 1.0
        self.orientation_weight = 1.0
        self.joint_center_weight = 0.1
        self.smoothness_weight = 0.01

    def solve(self, target_pose, current_joints, additional_objectives=None,
              max_iterations=1000, tolerance=1e-6):
        """
        Solve inverse kinematics as optimization problem
        """
        def objective_function(joint_angles):
            total_cost = 0.0

            # Compute forward kinematics
            transform = self.chain.compute_forward_kinematics(joint_angles)
            pos, quat = extract_position_orientation(transform)

            # Position error cost
            pos_error = target_pose[:3] - pos
            total_cost += self.position_weight * np.sum(pos_error**2)

            # Orientation error cost
            # Convert quaternions to rotation vectors for error computation
            target_rot = R.from_quat(target_pose[3:])
            current_rot = R.from_quat(quat)
            rot_error = (target_rot.inv() * current_rot).as_rotvec()
            total_cost += self.orientation_weight * np.sum(rot_error**2)

            # Joint centering cost (keep joints near center of range)
            for i, joint_name in enumerate(self.chain.joint_names):
                if joint_name in self.robot_model.joint_limits:
                    lower, upper = self.robot_model.joint_limits[joint_name]
                    center = (lower + upper) / 2
                    joint_error = joint_angles[i] - center
                    total_cost += self.joint_center_weight * joint_error**2

            # Smoothness cost (minimize joint velocity if previous position given)
            if hasattr(self, 'previous_joints') and self.previous_joints is not None:
                joint_smoothness = joint_angles - self.previous_joints
                total_cost += self.smoothness_weight * np.sum(joint_smoothness**2)

            # Additional objectives if provided
            if additional_objectives:
                for obj_func, weight in additional_objectives:
                    total_cost += weight * obj_func(joint_angles)

            return total_cost

        # Define constraints for joint limits
        constraints = []
        for i, joint_name in enumerate(self.chain.joint_names):
            if joint_name in self.robot_model.joint_limits:
                lower, upper = self.robot_model.joint_limits[joint_name]

                # Lower bound constraint: joint[i] >= lower
                constraints.append({
                    'type': 'ineq',
                    'fun': lambda x, idx=i, lb=lower: x[idx] - lb
                })

                # Upper bound constraint: joint[i] <= upper
                constraints.append({
                    'type': 'ineq',
                    'fun': lambda x, idx=i, ub=upper: ub - x[idx]
                })

        # Solve optimization problem
        result = minimize(
            objective_function,
            current_joints,
            method='SLSQP',
            constraints=constraints,
            options={'maxiter': max_iterations}
        )

        success = result.success and result.fun < tolerance

        # Store for next iteration (for smoothness)
        self.previous_joints = result.x.copy()

        return result.x, success, result.fun

def example_optimization_ik():
    """Example usage of optimization-based IK"""
    # Create a simple robot model
    robot = RobotModel()

    # Add a simple planar arm
    dh_params = [
        (1.0, 0, 0, 0),  # Link 1: a=1.0, alpha=0, d=0, theta_offset=0
        (1.0, 0, 0, 0),  # Link 2: a=1.0, alpha=0, d=0, theta_offset=0
        (0.5, 0, 0, 0)   # Link 3: a=0.5, alpha=0, d=0, theta_offset=0
    ]

    joint_names = ['joint1', 'joint2', 'joint3']
    robot.add_chain('arm', joint_names, dh_params)

    # Set joint limits
    for joint in joint_names:
        robot.set_joint_limits(joint, -np.pi, np.pi)

    # Target pose [x, y, z, qw, qx, qy, qz]
    target_pose = np.array([1.5, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0])  # Unit quaternion (no rotation)

    # Initial joint configuration
    initial_joints = np.array([0.0, 0.0, 0.0])

    # Create optimization-based IK solver
    ik_solver = OptimizationBasedIK(robot, 'arm')

    # Solve
    solution, success, final_cost = ik_solver.solve(target_pose, initial_joints)

    print(f"Optimization IK Result:")
    print(f"Success: {success}")
    print(f"Final cost: {final_cost}")
    print(f"Joint solution: {solution}")

    # Verify solution
    chain = robot.chains['arm']
    final_transform = chain.compute_forward_kinematics(solution)
    final_pos, final_quat = extract_position_orientation(final_transform)
    print(f"Final position: {final_pos}")
    print(f"Target position: {target_pose[:3]}")
    print(f"Position error: {np.linalg.norm(target_pose[:3] - final_pos)}")

    return solution, success
```

## Handling Kinematic Constraints

### Joint Limits

Joint limits are crucial for safe robot operation and must be considered in inverse kinematics:

```python
class JointLimitHandler:
    """
    Class to handle joint limit constraints in IK
    """

    def __init__(self, joint_limits):
        """
        joint_limits: dict with joint names as keys and (lower, upper) tuples as values
        """
        self.limits = joint_limits

    def apply_joint_limits(self, joint_angles, joint_names):
        """
        Apply joint limits to joint angles
        """
        limited_angles = joint_angles.copy()

        for i, joint_name in enumerate(joint_names):
            if joint_name in self.limits:
                lower, upper = self.limits[joint_name]
                limited_angles[i] = np.clip(limited_angles[i], lower, upper)

        return limited_angles

    def check_joint_limits(self, joint_angles, joint_names, tolerance=1e-6):
        """
        Check if joint angles are within limits
        """
        for i, joint_name in enumerate(joint_names):
            if joint_name in self.limits:
                lower, upper = self.limits[joint_name]
                angle = joint_angles[i]

                if angle < lower - tolerance or angle > upper + tolerance:
                    return False, f"Joint {joint_name} out of limits: {angle} not in [{lower}, {upper}]"

        return True, "All joints within limits"

    def get_joint_limit_constraints(self, joint_names):
        """
        Get constraint functions for optimization
        """
        constraints = []

        for i, joint_name in enumerate(joint_names):
            if joint_name in self.limits:
                lower, upper = self.limits[joint_name]

                # Lower bound: x[i] >= lower
                constraints.append({
                    'type': 'ineq',
                    'fun': lambda x, idx=i, lb=lower: x[idx] - lb
                })

                # Upper bound: x[i] <= upper
                constraints.append({
                    'type': 'ineq',
                    'fun': lambda x, idx=i, ub=upper: ub - x[idx]
                })

        return constraints
```

### Singularity Handling

Kinematic singularities occur when the Jacobian loses rank, making it impossible to achieve certain motions:

```python
class SingularityHandler:
    """
    Class to handle kinematic singularities
    """

    def __init__(self, threshold=1e-6):
        self.threshold = threshold

    def detect_singularity(self, jacobian, method='svd'):
        """
        Detect singularity in the Jacobian matrix
        """
        if method == 'svd':
            # Use SVD to check condition number
            U, s, Vh = np.linalg.svd(jacobian)
            condition_number = s[0] / (s[-1] + 1e-12)  # Add small value to avoid division by zero

            is_singular = condition_number > 1.0 / self.threshold
            return is_singular, condition_number
        elif method == 'determinant':
            # For square matrices, check determinant
            if jacobian.shape[0] == jacobian.shape[1]:
                det = np.linalg.det(jacobian @ jacobian.T)
                is_singular = abs(det) < self.threshold
                return is_singular, abs(det)
            else:
                return self.detect_singularity(jacobian, 'svd')

    def regularize_jacobian(self, jacobian):
        """
        Regularize Jacobian using damped least squares to handle singularities
        """
        J = jacobian
        damping = 0.01  # Damping factor

        # Damped least squares: J# = J.T @ inv(J @ J.T + damping^2 * I)
        JJT = J @ J.T
        damping_matrix = damping**2 * np.eye(JJT.shape[0])
        regularized_pseudo_inverse = J.T @ np.linalg.inv(JJT + damping_matrix)

        return regularized_pseudo_inverse

    def get_nullspace_projection(self, jacobian):
        """
        Get nullspace projection matrix for redundancy resolution
        """
        # J# is the pseudoinverse of J
        J_pinv = self.regularize_jacobian(jacobian)

        # Nullspace projection: N = I - J# @ J
        n_joints = jacobian.shape[1]
        nullspace_proj = np.eye(n_joints) - J_pinv @ jacobian

        return nullspace_proj
```

## Multi-Task Kinematic Control

For redundant robots, multiple tasks can be achieved simultaneously using nullspace optimization:

```python
class MultiTaskKinematicController:
    """
    Controller for multi-task kinematic control of redundant robots
    """

    def __init__(self, robot_model, chain_name):
        self.robot_model = robot_model
        self.chain_name = chain_name
        self.chain = robot_model.chains[chain_name]
        self.singularity_handler = SingularityHandler()
        self.joint_limit_handler = JointLimitHandler(robot_model.joint_limits)

    def solve_multi_task(self, primary_tasks, secondary_task=None,
                        current_joints=None, weights=None):
        """
        Solve multi-task inverse kinematics

        Args:
            primary_tasks: List of (task_jacobian, task_error) tuples
            secondary_task: Optional secondary task for redundancy resolution
            current_joints: Current joint configuration
            weights: Weights for each primary task
        """
        if current_joints is None:
            current_joints = np.zeros(len(self.chain.joint_names))

        if weights is None:
            weights = [1.0] * len(primary_tasks)

        # Stack primary task equations
        A_primary = []
        b_primary = []

        for i, (task_jac, task_err) in enumerate(primary_tasks):
            weighted_jac = weights[i] * task_jac
            A_primary.append(weighted_jac)
            b_primary.append(weights[i] * task_err)

        A_primary = np.vstack(A_primary)
        b_primary = np.concatenate(b_primary)

        # Solve primary task using damped least squares
        damping = 0.01
        JJT = A_primary @ A_primary.T
        damping_matrix = damping**2 * np.eye(JJT.shape[0])

        try:
            A_primary_pinv = A_primary.T @ np.linalg.inv(JJT + damping_matrix)
        except np.linalg.LinAlgError:
            # If matrix is singular, use SVD-based pseudoinverse
            U, s, Vh = np.linalg.svd(A_primary, full_matrices=False)
            s_inv = np.where(s > self.singularity_handler.threshold, 1./s, 0)
            A_primary_pinv = Vh.T @ np.diag(s_inv) @ U.T

        # Primary solution
        joint_change_primary = A_primary_pinv @ b_primary

        # If there's a secondary task, resolve redundancy
        joint_solution = joint_change_primary.copy()

        if secondary_task is not None:
            # Get nullspace of primary tasks
            I = np.eye(len(current_joints))
            nullspace_proj = I - A_primary_pinv @ A_primary

            # Apply secondary task in nullspace
            secondary_jac, secondary_error, secondary_weight = secondary_task
            secondary_target = secondary_weight * secondary_error

            # Project secondary Jacobian into nullspace
            secondary_jac_null = secondary_jac @ nullspace_proj

            # Solve secondary task in nullspace
            if secondary_jac_null.shape[0] > 0:
                secondary_damping = 0.01
                JJT_secondary = secondary_jac_null @ secondary_jac_null.T
                damping_matrix_secondary = secondary_damping**2 * np.eye(JJT_secondary.shape[0])

                try:
                    secondary_pinv = secondary_jac_null.T @ np.linalg.inv(JJT_secondary + damping_matrix_secondary)
                except np.linalg.LinAlgError:
                    U, s, Vh = np.linalg.svd(secondary_jac_null, full_matrices=False)
                    s_inv = np.where(s > self.singularity_handler.threshold, 1./s, 0)
                    secondary_pinv = Vh.T @ np.diag(s_inv) @ U.T

                joint_change_secondary = secondary_pinv @ secondary_target

                # Combine primary and secondary solutions
                joint_solution = joint_change_primary + nullspace_proj @ joint_change_secondary

        # Apply joint limits
        final_joints = current_joints + joint_solution
        final_joints = self.joint_limit_handler.apply_joint_limits(final_joints, self.chain.joint_names)

        return final_joints, joint_solution

def example_multi_task_ik():
    """
    Example of multi-task inverse kinematics
    """
    # Create a simple robot model
    robot = RobotModel()

    # Add a 7-DOF arm (redundant for 6D end-effector control)
    dh_params = [(1.0, 0, 0, 0) for _ in range(7)]
    joint_names = [f'joint{i+1}' for i in range(7)]
    robot.add_chain('arm', joint_names, dh_params)

    for joint in joint_names:
        robot.set_joint_limits(joint, -np.pi, np.pi)

    # Create multi-task controller
    controller = MultiTaskKinematicController(robot, 'arm')

    # Current joint configuration
    current_joints = np.zeros(7)

    # Primary task: end-effector position and orientation
    # In practice, we'd compute this using the robot's kinematic model
    end_effector_jac = np.random.randn(6, 7)  # 6D task space, 7D joint space
    end_effector_error = np.random.randn(6) * 0.1  # Small error

    primary_tasks = [(end_effector_jac, end_effector_error)]

    # Secondary task: maintain joint center configuration
    joint_center_jac = np.eye(7)  # Identity for joint space
    current_center_error = -current_joints  # Move toward center
    secondary_task = (joint_center_jac, current_center_error, 0.01)  # Low weight

    # Solve multi-task IK
    final_joints, joint_changes = controller.solve_multi_task(
        primary_tasks,
        secondary_task=secondary_task,
        current_joints=current_joints
    )

    print(f"Multi-task IK Result:")
    print(f"Current joints: {current_joints}")
    print(f"Final joints: {final_joints}")
    print(f"Joint changes: {joint_changes}")

    return final_joints
```

## Real-time Kinematic Control

For real-time applications, efficient algorithms are needed:

```python
class RealTimeKinematicController:
    """
    Efficient real-time kinematic controller
    """

    def __init__(self, robot_model, control_frequency=200):
        self.robot_model = robot_model
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency

        # Caching for efficiency
        self.last_joints = {}
        self.jacobian_cache = {}

        # Controllers for different chains
        self.chain_controllers = {}
        for chain_name in robot_model.chains.keys():
            self.chain_controllers[chain_name] = ChainController(
                robot_model.chains[chain_name],
                robot_model.joint_limits
            )

    def update(self, target_poses, current_joints, dt=None):
        """
        Update kinematic control

        Args:
            target_poses: Dict mapping chain names to target poses
            current_joints: Dict mapping joint names to current positions
            dt: Time step (defaults to controller's dt)
        """
        if dt is None:
            dt = self.dt

        new_joints = current_joints.copy()

        # Update each chain separately
        for chain_name, target_pose in target_poses.items():
            if chain_name in self.chain_controllers:
                chain_controller = self.chain_controllers[chain_name]

                # Extract chain-specific joints
                chain_joint_names = self.robot_model.chains[chain_name].joint_names
                chain_current_joints = np.array([current_joints[name] for name in chain_joint_names])

                # Compute new joints for this chain
                chain_new_joints = chain_controller.update(
                    target_pose, chain_current_joints, dt
                )

                # Update main joint dictionary
                for i, joint_name in enumerate(chain_joint_names):
                    new_joints[joint_name] = chain_new_joints[i]

        return new_joints

class ChainController:
    """
    Controller for a single kinematic chain
    """

    def __init__(self, chain_model, joint_limits):
        self.chain = chain_model
        self.joint_limits = joint_limits
        self.singularity_handler = SingularityHandler()
        self.last_joints = None
        self.integrator_state = None

    def update(self, target_pose, current_joints, dt):
        """
        Update control for single chain
        """
        # Compute error in task space
        current_transform = self.chain.compute_forward_kinematics(current_joints)
        current_pos, current_quat = extract_position_orientation(current_transform)

        # Position error
        pos_error = target_pose[:3] - current_pos

        # Orientation error (simplified)
        current_rot = R.from_quat(current_quat)
        target_rot = R.from_quat(target_pose[3:])
        rot_error = (target_rot.inv() * current_rot).as_rotvec()

        task_error = np.concatenate([pos_error, rot_error])

        # Compute Jacobian
        jacobian = self.chain.get_jacobian(current_joints)

        # Check for singularity
        is_singular, condition_num = self.singularity_handler.detect_singularity(jacobian)

        if is_singular:
            # Use damped least squares
            jacobian_pinv = self.singularity_handler.regularize_jacobian(jacobian)
        else:
            # Use standard pseudoinverse
            jacobian_pinv = np.linalg.pinv(jacobian)

        # Compute joint velocity
        joint_vel = jacobian_pinv @ task_error / dt

        # Integrate to get new joint positions
        new_joints = current_joints + joint_vel * dt

        # Apply joint limits
        for i, joint_name in enumerate(self.chain.joint_names):
            if joint_name in self.joint_limits:
                lower, upper = self.joint_limits[joint_name]
                new_joints[i] = np.clip(new_joints[i], lower, upper)

        self.last_joints = new_joints.copy()

        return new_joints

# Example of complete kinematic control system
def demonstrate_kinematic_control():
    """
    Demonstrate the complete kinematic control system
    """
    print("=== Kinematic Control Demonstration ===")

    # Create robot model
    robot = RobotModel()

    # Add arm and leg chains
    arm_dh = [(0.3, 0, 0, 0), (0.3, 0, 0, 0), (0.2, 0, 0, 0), (0.1, 0, 0, 0)]
    arm_joints = ['shoulder', 'elbow', 'wrist1', 'wrist2']
    robot.add_chain('right_arm', arm_joints, arm_dh)

    leg_dh = [(0.4, 0, 0, 0), (0.4, 0, 0, 0), (0.1, 0, 0, 0)]
    leg_joints = ['hip', 'knee', 'ankle']
    robot.add_chain('left_leg', leg_joints, leg_dh)

    # Set joint limits
    for joint in arm_joints + leg_joints:
        robot.set_joint_limits(joint, -np.pi/2, np.pi/2)

    # Create real-time controller
    controller = RealTimeKinematicController(robot, control_frequency=200)

    # Initial joint configuration
    initial_joints = {joint: 0.0 for joint in robot.all_joint_names}

    # Target poses
    target_poses = {
        'right_arm': np.array([0.6, 0.2, 0.2, 1.0, 0.0, 0.0, 0.0]),  # [pos, quat]
        'left_leg': np.array([0.0, 0.0, 0.5, 1.0, 0.0, 0.0, 0.0])
    }

    # Simulate control loop
    print("Starting kinematic control simulation...")

    for step in range(100):
        # Update control
        new_joints = controller.update(target_poses, initial_joints)

        # Update for next iteration
        initial_joints = new_joints

        # Print progress every 20 steps
        if step % 20 == 0:
            arm_joints = [new_joints[name] for name in arm_joints]
            leg_joints = [new_joints[name] for name in leg_joints]
            print(f"Step {step}: Arm joints = {np.round(arm_joints, 3)}, Leg joints = {np.round(leg_joints, 3)}")

    print("Kinematic control simulation completed.")

    return new_joints

if __name__ == "__main__":
    # Run examples
    solution, success = example_optimization_ik()
    multi_task_solution = example_multi_task_ik()
    final_joints = demonstrate_kinematic_control()

    print("\n=== Summary ===")
    print(f"Optimization IK: Success = {success}")
    print(f"Multi-task solution computed")
    print(f"Real-time control simulation completed")